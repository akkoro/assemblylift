// // Generated by `wit-bindgen` 0.8.0. DO NOT EDIT!
// pub mod wasi {
//     pub mod cli_base {

//         #[allow(clippy::all)]
//         pub mod environment {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             #[allow(clippy::all)]
//             /// Get the POSIX-style environment variables.
//             ///
//             /// Each environment variable is provided as a pair of string variable names
//             /// and string value.
//             ///
//             /// Morally, these are a value import, but until value imports are available
//             /// in the component model, this import function should return the same
//             /// values each time it is called.
//             pub fn get_environment() -> wit_bindgen::rt::vec::Vec<(
//                 wit_bindgen::rt::string::String,
//                 wit_bindgen::rt::string::String,
//             )> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:cli-base/environment")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-environment")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/environment_get-environment"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(ptr0);
//                     let base3 = *((ptr0 + 0) as *const i32);
//                     let len3 = *((ptr0 + 4) as *const i32);
//                     let mut result3 = Vec::with_capacity(len3 as usize);
//                     for i in 0..len3 {
//                         let base = base3 + i * 16;
//                         result3.push({
//                             let len1 = *((base + 4) as *const i32) as usize;
//                             let len2 = *((base + 12) as *const i32) as usize;

//                             (
//                                 {
//                                     #[cfg(not(debug_assertions))]
//                                     {
//                                         String::from_utf8_unchecked(Vec::from_raw_parts(
//                                             *((base + 0) as *const i32) as *mut _,
//                                             len1,
//                                             len1,
//                                         ))
//                                     }
//                                     #[cfg(debug_assertions)]
//                                     {
//                                         String::from_utf8(Vec::from_raw_parts(
//                                             *((base + 0) as *const i32) as *mut _,
//                                             len1,
//                                             len1,
//                                         ))
//                                         .unwrap()
//                                     }
//                                 },
//                                 {
//                                     #[cfg(not(debug_assertions))]
//                                     {
//                                         String::from_utf8_unchecked(Vec::from_raw_parts(
//                                             *((base + 8) as *const i32) as *mut _,
//                                             len2,
//                                             len2,
//                                         ))
//                                     }
//                                     #[cfg(debug_assertions)]
//                                     {
//                                         String::from_utf8(Vec::from_raw_parts(
//                                             *((base + 8) as *const i32) as *mut _,
//                                             len2,
//                                             len2,
//                                         ))
//                                         .unwrap()
//                                     }
//                                 },
//                             )
//                         });
//                     }
//                     wit_bindgen::rt::dealloc(base3, (len3 as usize) * 16, 4);
//                     result3
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get the POSIX-style arguments to the program.
//             pub fn get_arguments() -> wit_bindgen::rt::vec::Vec<wit_bindgen::rt::string::String> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:cli-base/environment")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-arguments")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/environment_get-arguments"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(ptr0);
//                     let base2 = *((ptr0 + 0) as *const i32);
//                     let len2 = *((ptr0 + 4) as *const i32);
//                     let mut result2 = Vec::with_capacity(len2 as usize);
//                     for i in 0..len2 {
//                         let base = base2 + i * 8;
//                         result2.push({
//                             let len1 = *((base + 4) as *const i32) as usize;

//                             {
//                                 #[cfg(not(debug_assertions))]
//                                 {
//                                     String::from_utf8_unchecked(Vec::from_raw_parts(
//                                         *((base + 0) as *const i32) as *mut _,
//                                         len1,
//                                         len1,
//                                     ))
//                                 }
//                                 #[cfg(debug_assertions)]
//                                 {
//                                     String::from_utf8(Vec::from_raw_parts(
//                                         *((base + 0) as *const i32) as *mut _,
//                                         len1,
//                                         len1,
//                                     ))
//                                     .unwrap()
//                                 }
//                             }
//                         });
//                     }
//                     wit_bindgen::rt::dealloc(base2, (len2 as usize) * 8, 4);
//                     result2
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod preopens {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Descriptor = super::super::super::wasi::filesystem::filesystem::Descriptor;
//             #[allow(clippy::all)]
//             /// Return the set of of preopened directories, and their path.
//             pub fn get_directories(
//             ) -> wit_bindgen::rt::vec::Vec<(Descriptor, wit_bindgen::rt::string::String)>
//             {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:cli-base/preopens")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-directories")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/preopens_get-directories"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(ptr0);
//                     let base2 = *((ptr0 + 0) as *const i32);
//                     let len2 = *((ptr0 + 4) as *const i32);
//                     let mut result2 = Vec::with_capacity(len2 as usize);
//                     for i in 0..len2 {
//                         let base = base2 + i * 12;
//                         result2.push({
//                             let len1 = *((base + 8) as *const i32) as usize;

//                             (*((base + 0) as *const i32) as u32, {
//                                 #[cfg(not(debug_assertions))]
//                                 {
//                                     String::from_utf8_unchecked(Vec::from_raw_parts(
//                                         *((base + 4) as *const i32) as *mut _,
//                                         len1,
//                                         len1,
//                                     ))
//                                 }
//                                 #[cfg(debug_assertions)]
//                                 {
//                                     String::from_utf8(Vec::from_raw_parts(
//                                         *((base + 4) as *const i32) as *mut _,
//                                         len1,
//                                         len1,
//                                     ))
//                                     .unwrap()
//                                 }
//                             })
//                         });
//                     }
//                     wit_bindgen::rt::dealloc(base2, (len2 as usize) * 12, 4);
//                     result2
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod exit {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             #[allow(clippy::all)]
//             /// Exit the curerent instance and any linked instances.
//             pub fn exit(status: Result<(), ()>) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     let result0 = match status {
//                         Ok(_) => 0i32,
//                         Err(_) => 1i32,
//                     };
//                     #[link(wasm_import_module = "wasi:cli-base/exit")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "exit")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/exit_exit"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(result0);
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod stdin {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type InputStream = super::super::super::wasi::io::streams::InputStream;
//             #[allow(clippy::all)]
//             pub fn get_stdin() -> InputStream {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:cli-base/stdin")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-stdin")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/stdin_get-stdin"
//                         )]
//                         fn wit_import() -> i32;
//                     }
//                     let ret = wit_import();
//                     ret as u32
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod stdout {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
//             #[allow(clippy::all)]
//             pub fn get_stdout() -> OutputStream {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:cli-base/stdout")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-stdout")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/stdout_get-stdout"
//                         )]
//                         fn wit_import() -> i32;
//                     }
//                     let ret = wit_import();
//                     ret as u32
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod stderr {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
//             #[allow(clippy::all)]
//             pub fn get_stderr() -> OutputStream {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:cli-base/stderr")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-stderr")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:cli-base/stderr_get-stderr"
//                         )]
//                         fn wit_import() -> i32;
//                     }
//                     let ret = wit_import();
//                     ret as u32
//                 }
//             }
//         }
//     }
//     pub mod clocks {

//         #[allow(clippy::all)]
//         pub mod wall_clock {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             /// A time and date in seconds plus nanoseconds.
//             #[repr(C)]
//             #[derive(Copy, Clone)]
//             pub struct Datetime {
//                 pub seconds: u64,
//                 pub nanoseconds: u32,
//             }
//             impl ::core::fmt::Debug for Datetime {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("Datetime")
//                         .field("seconds", &self.seconds)
//                         .field("nanoseconds", &self.nanoseconds)
//                         .finish()
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read the current value of the clock.
//             ///
//             /// This clock is not monotonic, therefore calling this function repeatedly
//             /// will not necessarily produce a sequence of non-decreasing values.
//             ///
//             /// The returned timestamps represent the number of seconds since
//             /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
//             /// also known as [Unix Time].
//             ///
//             /// The nanoseconds field of the output is always less than 1000000000.
//             ///
//             /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
//             /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
//             pub fn now() -> Datetime {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:clocks/wall-clock")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "now")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/wall-clock_now"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(ptr0);
//                     Datetime {
//                         seconds: *((ptr0 + 0) as *const i64) as u64,
//                         nanoseconds: *((ptr0 + 8) as *const i32) as u32,
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Query the resolution of the clock.
//             ///
//             /// The nanoseconds field of the output is always less than 1000000000.
//             pub fn resolution() -> Datetime {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:clocks/wall-clock")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "resolution")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/wall-clock_resolution"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(ptr0);
//                     Datetime {
//                         seconds: *((ptr0 + 0) as *const i64) as u64,
//                         nanoseconds: *((ptr0 + 8) as *const i32) as u32,
//                     }
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod monotonic_clock {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Pollable = super::super::super::wasi::poll::poll::Pollable;
//             /// A timestamp in nanoseconds.
//             pub type Instant = u64;
//             #[allow(clippy::all)]
//             /// Read the current value of the clock.
//             ///
//             /// The clock is monotonic, therefore calling this function repeatedly will
//             /// produce a sequence of non-decreasing values.
//             pub fn now() -> Instant {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:clocks/monotonic-clock")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "now")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/monotonic-clock_now"
//                         )]
//                         fn wit_import() -> i64;
//                     }
//                     let ret = wit_import();
//                     ret as u64
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Query the resolution of the clock.
//             pub fn resolution() -> Instant {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:clocks/monotonic-clock")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "resolution")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/monotonic-clock_resolution"
//                         )]
//                         fn wit_import() -> i64;
//                     }
//                     let ret = wit_import();
//                     ret as u64
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a `pollable` which will resolve once the specified time has been
//             /// reached.
//             pub fn subscribe(when: Instant, absolute: bool) -> Pollable {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:clocks/monotonic-clock")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/monotonic-clock_subscribe"
//                         )]
//                         fn wit_import(_: i64, _: i32) -> i32;
//                     }
//                     let ret = wit_import(
//                         wit_bindgen::rt::as_i64(when),
//                         match absolute {
//                             true => 1,
//                             false => 0,
//                         },
//                     );
//                     ret as u32
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod timezone {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
//             /// Information useful for displaying the timezone of a specific `datetime`.
//             ///
//             /// This information may vary within a single `timezone` to reflect daylight
//             /// saving time adjustments.
//             #[derive(Clone)]
//             pub struct TimezoneDisplay {
//                 /// The number of seconds difference between UTC time and the local
//                 /// time of the timezone.
//                 ///
//                 /// The returned value will always be less than 86400 which is the
//                 /// number of seconds in a day (24*60*60).
//                 ///
//                 /// In implementations that do not expose an actual time zone, this
//                 /// should return 0.
//                 pub utc_offset: i32,
//                 /// The abbreviated name of the timezone to display to a user. The name
//                 /// `UTC` indicates Coordinated Universal Time. Otherwise, this should
//                 /// reference local standards for the name of the time zone.
//                 ///
//                 /// In implementations that do not expose an actual time zone, this
//                 /// should be the string `UTC`.
//                 ///
//                 /// In time zones that do not have an applicable name, a formatted
//                 /// representation of the UTC offset may be returned, such as `-04:00`.
//                 pub name: wit_bindgen::rt::string::String,
//                 /// Whether daylight saving time is active.
//                 ///
//                 /// In implementations that do not expose an actual time zone, this
//                 /// should return false.
//                 pub in_daylight_saving_time: bool,
//             }
//             impl ::core::fmt::Debug for TimezoneDisplay {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("TimezoneDisplay")
//                         .field("utc-offset", &self.utc_offset)
//                         .field("name", &self.name)
//                         .field("in-daylight-saving-time", &self.in_daylight_saving_time)
//                         .finish()
//                 }
//             }
//             /// A timezone.
//             ///
//             /// In timezones that recognize daylight saving time, also known as daylight
//             /// time and summer time, the information returned from the functions varies
//             /// over time to reflect these adjustments.
//             ///
//             /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
//             pub type Timezone = u32;
//             #[allow(clippy::all)]
//             /// Return information needed to display the given `datetime`. This includes
//             /// the UTC offset, the time zone name, and a flag indicating whether
//             /// daylight saving time is active.
//             ///
//             /// If the timezone cannot be determined for the given `datetime`, return a
//             /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight
//             /// saving time.
//             pub fn display(this: Timezone, when: Datetime) -> TimezoneDisplay {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let super::super::super::wasi::clocks::wall_clock::Datetime {
//                         seconds: seconds0,
//                         nanoseconds: nanoseconds0,
//                     } = when;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:clocks/timezone")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "display")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/timezone_display"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(seconds0),
//                         wit_bindgen::rt::as_i32(nanoseconds0),
//                         ptr1,
//                     );
//                     let len2 = *((ptr1 + 8) as *const i32) as usize;
//                     TimezoneDisplay {
//                         utc_offset: *((ptr1 + 0) as *const i32),
//                         name: {
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 String::from_utf8_unchecked(Vec::from_raw_parts(
//                                     *((ptr1 + 4) as *const i32) as *mut _,
//                                     len2,
//                                     len2,
//                                 ))
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 String::from_utf8(Vec::from_raw_parts(
//                                     *((ptr1 + 4) as *const i32) as *mut _,
//                                     len2,
//                                     len2,
//                                 ))
//                                 .unwrap()
//                             }
//                         },
//                         in_daylight_saving_time: {
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr1 + 12) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr1 + 12) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         },
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// The same as `display`, but only return the UTC offset.
//             pub fn utc_offset(this: Timezone, when: Datetime) -> i32 {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     let super::super::super::wasi::clocks::wall_clock::Datetime {
//                         seconds: seconds0,
//                         nanoseconds: nanoseconds0,
//                     } = when;

//                     #[link(wasm_import_module = "wasi:clocks/timezone")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "utc-offset")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/timezone_utc-offset"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32) -> i32;
//                     }
//                     let ret = wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(seconds0),
//                         wit_bindgen::rt::as_i32(nanoseconds0),
//                     );
//                     ret
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified input-stream, after which it may no longer
//             /// be used.
//             pub fn drop_timezone(this: Timezone) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:clocks/timezone")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-timezone")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:clocks/timezone_drop-timezone"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//         }
//     }
//     pub mod filesystem {

//         #[allow(clippy::all)]
//         pub mod filesystem {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type InputStream = super::super::super::wasi::io::streams::InputStream;
//             pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
//             pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
//             wit_bindgen::bitflags::bitflags! {
//               /// Flags determining the method of how paths are resolved.
//               #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
//               pub struct PathFlags: u8 {
//                 /// As long as the resolved path corresponds to a symbolic link, it is
//                 /// expanded.
//                 const SYMLINK_FOLLOW = 1 << 0;
//               }
//             }
//             wit_bindgen::bitflags::bitflags! {
//               /// Open flags used by `open-at`.
//               #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
//               pub struct OpenFlags: u8 {
//                 /// Create file if it does not exist, similar to `O_CREAT` in POSIX.
//                 const CREATE = 1 << 0;
//                 /// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
//                 const DIRECTORY = 1 << 1;
//                 /// Fail if file already exists, similar to `O_EXCL` in POSIX.
//                 const EXCLUSIVE = 1 << 2;
//                 /// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
//                 const TRUNCATE = 1 << 3;
//               }
//             }
//             wit_bindgen::bitflags::bitflags! {
//               /// Permissions mode used by `open-at`, `change-file-permissions-at`, and
//               /// similar.
//               #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
//               pub struct Modes: u8 {
//                 /// True if the resource is considered readable by the containing
//                 /// filesystem.
//                 const READABLE = 1 << 0;
//                 /// True if the resource is considered writable by the containing
//                 /// filesystem.
//                 const WRITABLE = 1 << 1;
//                 /// True if the resource is considered executable by the containing
//                 /// filesystem. This does not apply to directories.
//                 const EXECUTABLE = 1 << 2;
//               }
//             }
//             /// Number of hard links to an inode.
//             pub type LinkCount = u64;
//             /// Filesystem object serial number that is unique within its file system.
//             pub type Inode = u64;
//             /// File size or length of a region within a file.
//             pub type Filesize = u64;
//             /// Error codes returned by functions, similar to `errno` in POSIX.
//             /// Not all of these error codes are returned by the functions provided by this
//             /// API; some are used in higher-level library layers, and others are provided
//             /// merely for alignment with POSIX.
//             #[repr(u8)]
//             #[derive(Clone, Copy, PartialEq, Eq)]
//             pub enum ErrorCode {
//                 /// Permission denied, similar to `EACCES` in POSIX.
//                 Access,
//                 /// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
//                 WouldBlock,
//                 /// Connection already in progress, similar to `EALREADY` in POSIX.
//                 Already,
//                 /// Bad descriptor, similar to `EBADF` in POSIX.
//                 BadDescriptor,
//                 /// Device or resource busy, similar to `EBUSY` in POSIX.
//                 Busy,
//                 /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
//                 Deadlock,
//                 /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
//                 Quota,
//                 /// File exists, similar to `EEXIST` in POSIX.
//                 Exist,
//                 /// File too large, similar to `EFBIG` in POSIX.
//                 FileTooLarge,
//                 /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
//                 IllegalByteSequence,
//                 /// Operation in progress, similar to `EINPROGRESS` in POSIX.
//                 InProgress,
//                 /// Interrupted function, similar to `EINTR` in POSIX.
//                 Interrupted,
//                 /// Invalid argument, similar to `EINVAL` in POSIX.
//                 Invalid,
//                 /// I/O error, similar to `EIO` in POSIX.
//                 Io,
//                 /// Is a directory, similar to `EISDIR` in POSIX.
//                 IsDirectory,
//                 /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
//                 Loop,
//                 /// Too many links, similar to `EMLINK` in POSIX.
//                 TooManyLinks,
//                 /// Message too large, similar to `EMSGSIZE` in POSIX.
//                 MessageSize,
//                 /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
//                 NameTooLong,
//                 /// No such device, similar to `ENODEV` in POSIX.
//                 NoDevice,
//                 /// No such file or directory, similar to `ENOENT` in POSIX.
//                 NoEntry,
//                 /// No locks available, similar to `ENOLCK` in POSIX.
//                 NoLock,
//                 /// Not enough space, similar to `ENOMEM` in POSIX.
//                 InsufficientMemory,
//                 /// No space left on device, similar to `ENOSPC` in POSIX.
//                 InsufficientSpace,
//                 /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
//                 NotDirectory,
//                 /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
//                 NotEmpty,
//                 /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
//                 NotRecoverable,
//                 /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
//                 Unsupported,
//                 /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
//                 NoTty,
//                 /// No such device or address, similar to `ENXIO` in POSIX.
//                 NoSuchDevice,
//                 /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
//                 Overflow,
//                 /// Operation not permitted, similar to `EPERM` in POSIX.
//                 NotPermitted,
//                 /// Broken pipe, similar to `EPIPE` in POSIX.
//                 Pipe,
//                 /// Read-only file system, similar to `EROFS` in POSIX.
//                 ReadOnly,
//                 /// Invalid seek, similar to `ESPIPE` in POSIX.
//                 InvalidSeek,
//                 /// Text file busy, similar to `ETXTBSY` in POSIX.
//                 TextFileBusy,
//                 /// Cross-device link, similar to `EXDEV` in POSIX.
//                 CrossDevice,
//             }
//             impl ErrorCode {
//                 pub fn name(&self) -> &'static str {
//                     match self {
//                         ErrorCode::Access => "access",
//                         ErrorCode::WouldBlock => "would-block",
//                         ErrorCode::Already => "already",
//                         ErrorCode::BadDescriptor => "bad-descriptor",
//                         ErrorCode::Busy => "busy",
//                         ErrorCode::Deadlock => "deadlock",
//                         ErrorCode::Quota => "quota",
//                         ErrorCode::Exist => "exist",
//                         ErrorCode::FileTooLarge => "file-too-large",
//                         ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
//                         ErrorCode::InProgress => "in-progress",
//                         ErrorCode::Interrupted => "interrupted",
//                         ErrorCode::Invalid => "invalid",
//                         ErrorCode::Io => "io",
//                         ErrorCode::IsDirectory => "is-directory",
//                         ErrorCode::Loop => "loop",
//                         ErrorCode::TooManyLinks => "too-many-links",
//                         ErrorCode::MessageSize => "message-size",
//                         ErrorCode::NameTooLong => "name-too-long",
//                         ErrorCode::NoDevice => "no-device",
//                         ErrorCode::NoEntry => "no-entry",
//                         ErrorCode::NoLock => "no-lock",
//                         ErrorCode::InsufficientMemory => "insufficient-memory",
//                         ErrorCode::InsufficientSpace => "insufficient-space",
//                         ErrorCode::NotDirectory => "not-directory",
//                         ErrorCode::NotEmpty => "not-empty",
//                         ErrorCode::NotRecoverable => "not-recoverable",
//                         ErrorCode::Unsupported => "unsupported",
//                         ErrorCode::NoTty => "no-tty",
//                         ErrorCode::NoSuchDevice => "no-such-device",
//                         ErrorCode::Overflow => "overflow",
//                         ErrorCode::NotPermitted => "not-permitted",
//                         ErrorCode::Pipe => "pipe",
//                         ErrorCode::ReadOnly => "read-only",
//                         ErrorCode::InvalidSeek => "invalid-seek",
//                         ErrorCode::TextFileBusy => "text-file-busy",
//                         ErrorCode::CrossDevice => "cross-device",
//                     }
//                 }
//                 pub fn message(&self) -> &'static str {
//                     match self {
//             ErrorCode::Access => "Permission denied, similar to `EACCES` in POSIX.",
//             ErrorCode::WouldBlock => "Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.",
//             ErrorCode::Already => "Connection already in progress, similar to `EALREADY` in POSIX.",
//             ErrorCode::BadDescriptor => "Bad descriptor, similar to `EBADF` in POSIX.",
//             ErrorCode::Busy => "Device or resource busy, similar to `EBUSY` in POSIX.",
//             ErrorCode::Deadlock => "Resource deadlock would occur, similar to `EDEADLK` in POSIX.",
//             ErrorCode::Quota => "Storage quota exceeded, similar to `EDQUOT` in POSIX.",
//             ErrorCode::Exist => "File exists, similar to `EEXIST` in POSIX.",
//             ErrorCode::FileTooLarge => "File too large, similar to `EFBIG` in POSIX.",
//             ErrorCode::IllegalByteSequence => "Illegal byte sequence, similar to `EILSEQ` in POSIX.",
//             ErrorCode::InProgress => "Operation in progress, similar to `EINPROGRESS` in POSIX.",
//             ErrorCode::Interrupted => "Interrupted function, similar to `EINTR` in POSIX.",
//             ErrorCode::Invalid => "Invalid argument, similar to `EINVAL` in POSIX.",
//             ErrorCode::Io => "I/O error, similar to `EIO` in POSIX.",
//             ErrorCode::IsDirectory => "Is a directory, similar to `EISDIR` in POSIX.",
//             ErrorCode::Loop => "Too many levels of symbolic links, similar to `ELOOP` in POSIX.",
//             ErrorCode::TooManyLinks => "Too many links, similar to `EMLINK` in POSIX.",
//             ErrorCode::MessageSize => "Message too large, similar to `EMSGSIZE` in POSIX.",
//             ErrorCode::NameTooLong => "Filename too long, similar to `ENAMETOOLONG` in POSIX.",
//             ErrorCode::NoDevice => "No such device, similar to `ENODEV` in POSIX.",
//             ErrorCode::NoEntry => "No such file or directory, similar to `ENOENT` in POSIX.",
//             ErrorCode::NoLock => "No locks available, similar to `ENOLCK` in POSIX.",
//             ErrorCode::InsufficientMemory => "Not enough space, similar to `ENOMEM` in POSIX.",
//             ErrorCode::InsufficientSpace => "No space left on device, similar to `ENOSPC` in POSIX.",
//             ErrorCode::NotDirectory => "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.",
//             ErrorCode::NotEmpty => "Directory not empty, similar to `ENOTEMPTY` in POSIX.",
//             ErrorCode::NotRecoverable => "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.",
//             ErrorCode::Unsupported => "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.",
//             ErrorCode::NoTty => "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.",
//             ErrorCode::NoSuchDevice => "No such device or address, similar to `ENXIO` in POSIX.",
//             ErrorCode::Overflow => "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.",
//             ErrorCode::NotPermitted => "Operation not permitted, similar to `EPERM` in POSIX.",
//             ErrorCode::Pipe => "Broken pipe, similar to `EPIPE` in POSIX.",
//             ErrorCode::ReadOnly => "Read-only file system, similar to `EROFS` in POSIX.",
//             ErrorCode::InvalidSeek => "Invalid seek, similar to `ESPIPE` in POSIX.",
//             ErrorCode::TextFileBusy => "Text file busy, similar to `ETXTBSY` in POSIX.",
//             ErrorCode::CrossDevice => "Cross-device link, similar to `EXDEV` in POSIX.",
//           }
//                 }
//             }
//             impl ::core::fmt::Debug for ErrorCode {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("ErrorCode")
//                         .field("code", &(*self as i32))
//                         .field("name", &self.name())
//                         .field("message", &self.message())
//                         .finish()
//                 }
//             }
//             impl ::core::fmt::Display for ErrorCode {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     write!(f, "{} (error {})", self.name(), *self as i32)
//                 }
//             }

//             impl std::error::Error for ErrorCode {}
//             /// A stream of directory entries.
//             ///
//             /// This [represents a stream of `dir-entry`](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Streams).
//             pub type DirectoryEntryStream = u32;
//             /// Identifier for a device containing a file system. Can be used in
//             /// combination with `inode` to uniquely identify a file or directory in
//             /// the filesystem.
//             pub type Device = u64;
//             /// The type of a filesystem object referenced by a descriptor.
//             ///
//             /// Note: This was called `filetype` in earlier versions of WASI.
//             #[repr(u8)]
//             #[derive(Clone, Copy, PartialEq, Eq)]
//             pub enum DescriptorType {
//                 /// The type of the descriptor or file is unknown or is different from
//                 /// any of the other types specified.
//                 Unknown,
//                 /// The descriptor refers to a block device inode.
//                 BlockDevice,
//                 /// The descriptor refers to a character device inode.
//                 CharacterDevice,
//                 /// The descriptor refers to a directory inode.
//                 Directory,
//                 /// The descriptor refers to a named pipe.
//                 Fifo,
//                 /// The file refers to a symbolic link inode.
//                 SymbolicLink,
//                 /// The descriptor refers to a regular file inode.
//                 RegularFile,
//                 /// The descriptor refers to a socket.
//                 Socket,
//             }
//             impl ::core::fmt::Debug for DescriptorType {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         DescriptorType::Unknown => {
//                             f.debug_tuple("DescriptorType::Unknown").finish()
//                         }
//                         DescriptorType::BlockDevice => {
//                             f.debug_tuple("DescriptorType::BlockDevice").finish()
//                         }
//                         DescriptorType::CharacterDevice => {
//                             f.debug_tuple("DescriptorType::CharacterDevice").finish()
//                         }
//                         DescriptorType::Directory => {
//                             f.debug_tuple("DescriptorType::Directory").finish()
//                         }
//                         DescriptorType::Fifo => f.debug_tuple("DescriptorType::Fifo").finish(),
//                         DescriptorType::SymbolicLink => {
//                             f.debug_tuple("DescriptorType::SymbolicLink").finish()
//                         }
//                         DescriptorType::RegularFile => {
//                             f.debug_tuple("DescriptorType::RegularFile").finish()
//                         }
//                         DescriptorType::Socket => f.debug_tuple("DescriptorType::Socket").finish(),
//                     }
//                 }
//             }
//             /// A directory entry.
//             #[derive(Clone)]
//             pub struct DirectoryEntry {
//                 /// The serial number of the object referred to by this directory entry.
//                 /// May be none if the inode value is not known.
//                 ///
//                 /// When this is none, libc implementations might do an extra `stat-at`
//                 /// call to retrieve the inode number to fill their `d_ino` fields, so
//                 /// implementations which can set this to a non-none value should do so.
//                 pub inode: Option<Inode>,
//                 /// The type of the file referred to by this directory entry.
//                 pub type_: DescriptorType,
//                 /// The name of the object.
//                 pub name: wit_bindgen::rt::string::String,
//             }
//             impl ::core::fmt::Debug for DirectoryEntry {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("DirectoryEntry")
//                         .field("inode", &self.inode)
//                         .field("type", &self.type_)
//                         .field("name", &self.name)
//                         .finish()
//                 }
//             }
//             wit_bindgen::bitflags::bitflags! {
//               /// Descriptor flags.
//               ///
//               /// Note: This was called `fdflags` in earlier versions of WASI.
//               #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
//               pub struct DescriptorFlags: u8 {
//                 /// Read mode: Data can be read.
//                 const READ = 1 << 0;
//                 /// Write mode: Data can be written to.
//                 const WRITE = 1 << 1;
//                 /// Request that writes be performed according to synchronized I/O file
//                 /// integrity completion. The data stored in the file and the file's
//                 /// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
//                 ///
//                 /// The precise semantics of this operation have not yet been defined for
//                 /// WASI. At this time, it should be interpreted as a request, and not a
//                 /// requirement.
//                 const FILE_INTEGRITY_SYNC = 1 << 2;
//                 /// Request that writes be performed according to synchronized I/O data
//                 /// integrity completion. Only the data stored in the file is
//                 /// synchronized. This is similar to `O_DSYNC` in POSIX.
//                 ///
//                 /// The precise semantics of this operation have not yet been defined for
//                 /// WASI. At this time, it should be interpreted as a request, and not a
//                 /// requirement.
//                 const DATA_INTEGRITY_SYNC = 1 << 3;
//                 /// Requests that reads be performed at the same level of integrety
//                 /// requested for writes. This is similar to `O_RSYNC` in POSIX.
//                 ///
//                 /// The precise semantics of this operation have not yet been defined for
//                 /// WASI. At this time, it should be interpreted as a request, and not a
//                 /// requirement.
//                 const REQUESTED_WRITE_SYNC = 1 << 4;
//                 /// Mutating directories mode: Directory contents may be mutated.
//                 ///
//                 /// When this flag is unset on a descriptor, operations using the
//                 /// descriptor which would create, rename, delete, modify the data or
//                 /// metadata of filesystem objects, or obtain another handle which
//                 /// would permit any of those, shall fail with `error-code::read-only` if
//                 /// they would otherwise succeed.
//                 ///
//                 /// This may only be set on directories.
//                 const MUTATE_DIRECTORY = 1 << 5;
//               }
//             }
//             /// A descriptor is a reference to a filesystem object, which may be a file,
//             /// directory, named pipe, special file, or other object on which filesystem
//             /// calls may be made.
//             ///
//             /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
//             pub type Descriptor = u32;
//             /// When setting a timestamp, this gives the value to set it to.
//             #[derive(Clone, Copy)]
//             pub enum NewTimestamp {
//                 /// Leave the timestamp set to its previous value.
//                 NoChange,
//                 /// Set the timestamp to the current time of the system clock associated
//                 /// with the filesystem.
//                 Now,
//                 /// Set the timestamp to the given value.
//                 Timestamp(Datetime),
//             }
//             impl ::core::fmt::Debug for NewTimestamp {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         NewTimestamp::NoChange => f.debug_tuple("NewTimestamp::NoChange").finish(),
//                         NewTimestamp::Now => f.debug_tuple("NewTimestamp::Now").finish(),
//                         NewTimestamp::Timestamp(e) => {
//                             f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
//                         }
//                     }
//                 }
//             }
//             /// File attributes.
//             ///
//             /// Note: This was called `filestat` in earlier versions of WASI.
//             #[repr(C)]
//             #[derive(Copy, Clone)]
//             pub struct DescriptorStat {
//                 /// Device ID of device containing the file.
//                 pub device: Device,
//                 /// File serial number.
//                 pub inode: Inode,
//                 /// File type.
//                 pub type_: DescriptorType,
//                 /// Number of hard links to the file.
//                 pub link_count: LinkCount,
//                 /// For regular files, the file size in bytes. For symbolic links, the
//                 /// length in bytes of the pathname contained in the symbolic link.
//                 pub size: Filesize,
//                 /// Last data access timestamp.
//                 pub data_access_timestamp: Datetime,
//                 /// Last data modification timestamp.
//                 pub data_modification_timestamp: Datetime,
//                 /// Last file status change timestamp.
//                 pub status_change_timestamp: Datetime,
//             }
//             impl ::core::fmt::Debug for DescriptorStat {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("DescriptorStat")
//                         .field("device", &self.device)
//                         .field("inode", &self.inode)
//                         .field("type", &self.type_)
//                         .field("link-count", &self.link_count)
//                         .field("size", &self.size)
//                         .field("data-access-timestamp", &self.data_access_timestamp)
//                         .field(
//                             "data-modification-timestamp",
//                             &self.data_modification_timestamp,
//                         )
//                         .field("status-change-timestamp", &self.status_change_timestamp)
//                         .finish()
//                 }
//             }
//             /// File or memory access pattern advisory information.
//             #[repr(u8)]
//             #[derive(Clone, Copy, PartialEq, Eq)]
//             pub enum Advice {
//                 /// The application has no advice to give on its behavior with respect
//                 /// to the specified data.
//                 Normal,
//                 /// The application expects to access the specified data sequentially
//                 /// from lower offsets to higher offsets.
//                 Sequential,
//                 /// The application expects to access the specified data in a random
//                 /// order.
//                 Random,
//                 /// The application expects to access the specified data in the near
//                 /// future.
//                 WillNeed,
//                 /// The application expects that it will not access the specified data
//                 /// in the near future.
//                 DontNeed,
//                 /// The application expects to access the specified data once and then
//                 /// not reuse it thereafter.
//                 NoReuse,
//             }
//             impl ::core::fmt::Debug for Advice {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         Advice::Normal => f.debug_tuple("Advice::Normal").finish(),
//                         Advice::Sequential => f.debug_tuple("Advice::Sequential").finish(),
//                         Advice::Random => f.debug_tuple("Advice::Random").finish(),
//                         Advice::WillNeed => f.debug_tuple("Advice::WillNeed").finish(),
//                         Advice::DontNeed => f.debug_tuple("Advice::DontNeed").finish(),
//                         Advice::NoReuse => f.debug_tuple("Advice::NoReuse").finish(),
//                     }
//                 }
//             }
//             /// Access type used by `access-at`.
//             #[derive(Clone, Copy)]
//             pub enum AccessType {
//                 /// Test for readability, writeability, or executability.
//                 Access(Modes),
//                 /// Test whether the path exists.
//                 Exists,
//             }
//             impl ::core::fmt::Debug for AccessType {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         AccessType::Access(e) => {
//                             f.debug_tuple("AccessType::Access").field(e).finish()
//                         }
//                         AccessType::Exists => f.debug_tuple("AccessType::Exists").finish(),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return a stream for reading from a file.
//             ///
//             /// Multiple read, write, and append streams may be active on the same open
//             /// file and they do not interfere with each other.
//             ///
//             /// Note: This allows using `wasi:io/streams.read`, which is similar to `read` in POSIX.
//             pub fn read_via_stream(
//                 this: Descriptor,
//                 offset: Filesize,
//             ) -> Result<InputStream, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "read-via-stream")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_read-via-stream"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(offset),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return a stream for writing to a file.
//             ///
//             /// Note: This allows using `wasi:io/streams.write`, which is similar to `write` in
//             /// POSIX.
//             pub fn write_via_stream(
//                 this: Descriptor,
//                 offset: Filesize,
//             ) -> Result<OutputStream, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "write-via-stream")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_write-via-stream"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(offset),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return a stream for appending to a file.
//             ///
//             /// Note: This allows using `wasi:io/streams.write`, which is similar to `write` with
//             /// `O_APPEND` in in POSIX.
//             pub fn append_via_stream(this: Descriptor) -> Result<OutputStream, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "append-via-stream")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_append-via-stream"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Provide file advisory information on a descriptor.
//             ///
//             /// This is similar to `posix_fadvise` in POSIX.
//             pub fn advise(
//                 this: Descriptor,
//                 offset: Filesize,
//                 length: Filesize,
//                 advice: Advice,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "advise")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_advise"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i64, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(offset),
//                         wit_bindgen::rt::as_i64(length),
//                         match advice {
//                             Advice::Normal => 0,
//                             Advice::Sequential => 1,
//                             Advice::Random => 2,
//                             Advice::WillNeed => 3,
//                             Advice::DontNeed => 4,
//                             Advice::NoReuse => 5,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Synchronize the data of a file to disk.
//             ///
//             /// This function succeeds with no effect if the file descriptor is not
//             /// opened for writing.
//             ///
//             /// Note: This is similar to `fdatasync` in POSIX.
//             pub fn sync_data(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "sync-data")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_sync-data"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get flags associated with a descriptor.
//             ///
//             /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
//             ///
//             /// Note: This returns the value that was the `fs_flags` value returned
//             /// from `fdstat_get` in earlier versions of WASI.
//             pub fn get_flags(this: Descriptor) -> Result<DescriptorFlags, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-flags")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_get-flags"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(DescriptorFlags::empty()
//                             | DescriptorFlags::from_bits_retain(
//                                 ((i32::from(*((ptr0 + 1) as *const u8)) as u8) << 0) as _,
//                             )),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get the dynamic type of a descriptor.
//             ///
//             /// Note: This returns the same value as the `type` field of the `fd-stat`
//             /// returned by `stat`, `stat-at` and similar.
//             ///
//             /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
//             /// by `fstat` in POSIX.
//             ///
//             /// Note: This returns the value that was the `fs_filetype` value returned
//             /// from `fdstat_get` in earlier versions of WASI.
//             pub fn get_type(this: Descriptor) -> Result<DescriptorType, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-type")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_get-type"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => DescriptorType::Unknown,
//                                     1 => DescriptorType::BlockDevice,
//                                     2 => DescriptorType::CharacterDevice,
//                                     3 => DescriptorType::Directory,
//                                     4 => DescriptorType::Fifo,
//                                     5 => DescriptorType::SymbolicLink,
//                                     6 => DescriptorType::RegularFile,
//                                     7 => DescriptorType::Socket,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, DescriptorType>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Adjust the size of an open file. If this increases the file's size, the
//             /// extra bytes are filled with zeros.
//             ///
//             /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
//             pub fn set_size(this: Descriptor, size: Filesize) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_set-size"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(size),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Adjust the timestamps of an open file or directory.
//             ///
//             /// Note: This is similar to `futimens` in POSIX.
//             ///
//             /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
//             pub fn set_times(
//                 this: Descriptor,
//                 data_access_timestamp: NewTimestamp,
//                 data_modification_timestamp: NewTimestamp,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let (result1_0, result1_1, result1_2) = match data_access_timestamp {
//                         NewTimestamp::NoChange => (0i32, 0i64, 0i32),
//                         NewTimestamp::Now => (1i32, 0i64, 0i32),
//                         NewTimestamp::Timestamp(e) => {
//                             let super::super::super::wasi::clocks::wall_clock::Datetime {
//                                 seconds: seconds0,
//                                 nanoseconds: nanoseconds0,
//                             } = e;

//                             (
//                                 2i32,
//                                 wit_bindgen::rt::as_i64(seconds0),
//                                 wit_bindgen::rt::as_i32(nanoseconds0),
//                             )
//                         }
//                     };
//                     let (result3_0, result3_1, result3_2) = match data_modification_timestamp {
//                         NewTimestamp::NoChange => (0i32, 0i64, 0i32),
//                         NewTimestamp::Now => (1i32, 0i64, 0i32),
//                         NewTimestamp::Timestamp(e) => {
//                             let super::super::super::wasi::clocks::wall_clock::Datetime {
//                                 seconds: seconds2,
//                                 nanoseconds: nanoseconds2,
//                             } = e;

//                             (
//                                 2i32,
//                                 wit_bindgen::rt::as_i64(seconds2),
//                                 wit_bindgen::rt::as_i32(nanoseconds2),
//                             )
//                         }
//                     };
//                     let ptr4 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-times")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_set-times"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i64,
//                             _: i32,
//                             _: i32,
//                             _: i64,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         result1_0,
//                         result1_1,
//                         result1_2,
//                         result3_0,
//                         result3_1,
//                         result3_2,
//                         ptr4,
//                     );
//                     match i32::from(*((ptr4 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr4 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr4 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read from a descriptor, without using and updating the descriptor's offset.
//             ///
//             /// This function returns a list of bytes containing the data that was
//             /// read, along with a bool which, when true, indicates that the end of the
//             /// file was reached. The returned list will contain up to `length` bytes; it
//             /// may return fewer than requested, if the end of the file is reached or
//             /// if the I/O operation is interrupted.
//             ///
//             /// In the future, this may change to return a `stream<u8, error-code>`.
//             ///
//             /// Note: This is similar to `pread` in POSIX.
//             pub fn read(
//                 this: Descriptor,
//                 length: Filesize,
//                 offset: Filesize,
//             ) -> Result<(wit_bindgen::rt::vec::Vec<u8>, bool), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "read")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_read"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(length),
//                         wit_bindgen::rt::as_i64(offset),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             let len1 = *((ptr0 + 8) as *const i32) as usize;

//                             (
//                                 Vec::from_raw_parts(
//                                     *((ptr0 + 4) as *const i32) as *mut _,
//                                     len1,
//                                     len1,
//                                 ),
//                                 {
//                                     #[cfg(not(debug_assertions))]
//                                     {
//                                         ::core::mem::transmute::<u8, bool>(i32::from(
//                                             *((ptr0 + 12) as *const u8),
//                                         )
//                                             as u8)
//                                     }
//                                     #[cfg(debug_assertions)]
//                                     {
//                                         match i32::from(*((ptr0 + 12) as *const u8)) {
//                                             0 => false,
//                                             1 => true,
//                                             _ => panic!("invalid bool discriminant"),
//                                         }
//                                     }
//                                 },
//                             )
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Write to a descriptor, without using and updating the descriptor's offset.
//             ///
//             /// It is valid to write past the end of a file; the file is extended to the
//             /// extent of the write, with bytes between the previous end and the start of
//             /// the write set to zero.
//             ///
//             /// In the future, this may change to take a `stream<u8, error-code>`.
//             ///
//             /// Note: This is similar to `pwrite` in POSIX.
//             pub fn write(
//                 this: Descriptor,
//                 buffer: &[u8],
//                 offset: Filesize,
//             ) -> Result<Filesize, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = buffer;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "write")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_write"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         ptr0,
//                         len0,
//                         wit_bindgen::rt::as_i64(offset),
//                         ptr1,
//                     );
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok(*((ptr1 + 8) as *const i64) as u64),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr1 + 8) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr1 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read directory entries from a directory.
//             ///
//             /// On filesystems where directories contain entries referring to themselves
//             /// and their parents, often named `.` and `..` respectively, these entries
//             /// are omitted.
//             ///
//             /// This always returns a new stream which starts at the beginning of the
//             /// directory. Multiple streams may be active on the same directory, and they
//             /// do not interfere with each other.
//             pub fn read_directory(this: Descriptor) -> Result<DirectoryEntryStream, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "read-directory")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_read-directory"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Synchronize the data and metadata of a file to disk.
//             ///
//             /// This function succeeds with no effect if the file descriptor is not
//             /// opened for writing.
//             ///
//             /// Note: This is similar to `fsync` in POSIX.
//             pub fn sync(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "sync")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_sync"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a directory.
//             ///
//             /// Note: This is similar to `mkdirat` in POSIX.
//             pub fn create_directory_at(this: Descriptor, path: &str) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = path;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "create-directory-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_create-directory-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1);
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr1 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr1 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return the attributes of an open file or directory.
//             ///
//             /// Note: This is similar to `fstat` in POSIX.
//             ///
//             /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
//             pub fn stat(this: Descriptor) -> Result<DescriptorStat, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 96]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "stat")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_stat"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(DescriptorStat {
//                             device: *((ptr0 + 8) as *const i64) as u64,
//                             inode: *((ptr0 + 16) as *const i64) as u64,
//                             type_: {
//                                 #[cfg(debug_assertions)]
//                                 {
//                                     match i32::from(*((ptr0 + 24) as *const u8)) {
//                                         0 => DescriptorType::Unknown,
//                                         1 => DescriptorType::BlockDevice,
//                                         2 => DescriptorType::CharacterDevice,
//                                         3 => DescriptorType::Directory,
//                                         4 => DescriptorType::Fifo,
//                                         5 => DescriptorType::SymbolicLink,
//                                         6 => DescriptorType::RegularFile,
//                                         7 => DescriptorType::Socket,
//                                         _ => panic!("invalid enum discriminant"),
//                                     }
//                                 }
//                                 #[cfg(not(debug_assertions))]
//                                 {
//                                     ::core::mem::transmute::<_, DescriptorType>(i32::from(
//                                         *((ptr0 + 24) as *const u8),
//                                     )
//                                         as u8)
//                                 }
//                             },
//                             link_count: *((ptr0 + 32) as *const i64) as u64,
//                             size: *((ptr0 + 40) as *const i64) as u64,
//                             data_access_timestamp:
//                                 super::super::super::wasi::clocks::wall_clock::Datetime {
//                                     seconds: *((ptr0 + 48) as *const i64) as u64,
//                                     nanoseconds: *((ptr0 + 56) as *const i32) as u32,
//                                 },
//                             data_modification_timestamp:
//                                 super::super::super::wasi::clocks::wall_clock::Datetime {
//                                     seconds: *((ptr0 + 64) as *const i64) as u64,
//                                     nanoseconds: *((ptr0 + 72) as *const i32) as u32,
//                                 },
//                             status_change_timestamp:
//                                 super::super::super::wasi::clocks::wall_clock::Datetime {
//                                     seconds: *((ptr0 + 80) as *const i64) as u64,
//                                     nanoseconds: *((ptr0 + 88) as *const i32) as u32,
//                                 },
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 8) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return the attributes of a file or directory.
//             ///
//             /// Note: This is similar to `fstatat` in POSIX.
//             ///
//             /// Note: This was called `path_filestat_get` in earlier versions of WASI.
//             pub fn stat_at(
//                 this: Descriptor,
//                 path_flags: PathFlags,
//                 path: &str,
//             ) -> Result<DescriptorStat, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 96]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = path_flags;
//                     let vec1 = path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let ptr2 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "stat-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_stat-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         ptr2,
//                     );
//                     match i32::from(*((ptr2 + 0) as *const u8)) {
//                         0 => Ok(DescriptorStat {
//                             device: *((ptr2 + 8) as *const i64) as u64,
//                             inode: *((ptr2 + 16) as *const i64) as u64,
//                             type_: {
//                                 #[cfg(debug_assertions)]
//                                 {
//                                     match i32::from(*((ptr2 + 24) as *const u8)) {
//                                         0 => DescriptorType::Unknown,
//                                         1 => DescriptorType::BlockDevice,
//                                         2 => DescriptorType::CharacterDevice,
//                                         3 => DescriptorType::Directory,
//                                         4 => DescriptorType::Fifo,
//                                         5 => DescriptorType::SymbolicLink,
//                                         6 => DescriptorType::RegularFile,
//                                         7 => DescriptorType::Socket,
//                                         _ => panic!("invalid enum discriminant"),
//                                     }
//                                 }
//                                 #[cfg(not(debug_assertions))]
//                                 {
//                                     ::core::mem::transmute::<_, DescriptorType>(i32::from(
//                                         *((ptr2 + 24) as *const u8),
//                                     )
//                                         as u8)
//                                 }
//                             },
//                             link_count: *((ptr2 + 32) as *const i64) as u64,
//                             size: *((ptr2 + 40) as *const i64) as u64,
//                             data_access_timestamp:
//                                 super::super::super::wasi::clocks::wall_clock::Datetime {
//                                     seconds: *((ptr2 + 48) as *const i64) as u64,
//                                     nanoseconds: *((ptr2 + 56) as *const i32) as u32,
//                                 },
//                             data_modification_timestamp:
//                                 super::super::super::wasi::clocks::wall_clock::Datetime {
//                                     seconds: *((ptr2 + 64) as *const i64) as u64,
//                                     nanoseconds: *((ptr2 + 72) as *const i32) as u32,
//                                 },
//                             status_change_timestamp:
//                                 super::super::super::wasi::clocks::wall_clock::Datetime {
//                                     seconds: *((ptr2 + 80) as *const i64) as u64,
//                                     nanoseconds: *((ptr2 + 88) as *const i32) as u32,
//                                 },
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr2 + 8) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr2 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Adjust the timestamps of a file or directory.
//             ///
//             /// Note: This is similar to `utimensat` in POSIX.
//             ///
//             /// Note: This was called `path_filestat_set_times` in earlier versions of
//             /// WASI.
//             pub fn set_times_at(
//                 this: Descriptor,
//                 path_flags: PathFlags,
//                 path: &str,
//                 data_access_timestamp: NewTimestamp,
//                 data_modification_timestamp: NewTimestamp,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = path_flags;
//                     let vec1 = path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let (result3_0, result3_1, result3_2) = match data_access_timestamp {
//                         NewTimestamp::NoChange => (0i32, 0i64, 0i32),
//                         NewTimestamp::Now => (1i32, 0i64, 0i32),
//                         NewTimestamp::Timestamp(e) => {
//                             let super::super::super::wasi::clocks::wall_clock::Datetime {
//                                 seconds: seconds2,
//                                 nanoseconds: nanoseconds2,
//                             } = e;

//                             (
//                                 2i32,
//                                 wit_bindgen::rt::as_i64(seconds2),
//                                 wit_bindgen::rt::as_i32(nanoseconds2),
//                             )
//                         }
//                     };
//                     let (result5_0, result5_1, result5_2) = match data_modification_timestamp {
//                         NewTimestamp::NoChange => (0i32, 0i64, 0i32),
//                         NewTimestamp::Now => (1i32, 0i64, 0i32),
//                         NewTimestamp::Timestamp(e) => {
//                             let super::super::super::wasi::clocks::wall_clock::Datetime {
//                                 seconds: seconds4,
//                                 nanoseconds: nanoseconds4,
//                             } = e;

//                             (
//                                 2i32,
//                                 wit_bindgen::rt::as_i64(seconds4),
//                                 wit_bindgen::rt::as_i32(nanoseconds4),
//                             )
//                         }
//                     };
//                     let ptr6 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-times-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_set-times-at"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i64,
//                             _: i32,
//                             _: i32,
//                             _: i64,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         result3_0,
//                         result3_1,
//                         result3_2,
//                         result5_0,
//                         result5_1,
//                         result5_2,
//                         ptr6,
//                     );
//                     match i32::from(*((ptr6 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr6 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr6 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a hard link.
//             ///
//             /// Note: This is similar to `linkat` in POSIX.
//             pub fn link_at(
//                 this: Descriptor,
//                 old_path_flags: PathFlags,
//                 old_path: &str,
//                 new_descriptor: Descriptor,
//                 new_path: &str,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = old_path_flags;
//                     let vec1 = old_path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let vec2 = new_path;
//                     let ptr2 = vec2.as_ptr() as i32;
//                     let len2 = vec2.len() as i32;
//                     let ptr3 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "link-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_link-at"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         wit_bindgen::rt::as_i32(new_descriptor),
//                         ptr2,
//                         len2,
//                         ptr3,
//                     );
//                     match i32::from(*((ptr3 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr3 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr3 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Open a file or directory.
//             ///
//             /// The returned descriptor is not guaranteed to be the lowest-numbered
//             /// descriptor not currently open/ it is randomized to prevent applications
//             /// from depending on making assumptions about indexes, since this is
//             /// error-prone in multi-threaded contexts. The returned descriptor is
//             /// guaranteed to be less than 2**31.
//             ///
//             /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
//             /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
//             /// `open-at` fails with `error-code::read-only`.
//             ///
//             /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
//             /// contains `truncate` or `create`, and the base descriptor doesn't have
//             /// `descriptor-flags::mutate-directory` set, `open-at` fails with
//             /// `error-code::read-only`.
//             ///
//             /// Note: This is similar to `openat` in POSIX.
//             pub fn open_at(
//                 this: Descriptor,
//                 path_flags: PathFlags,
//                 path: &str,
//                 open_flags: OpenFlags,
//                 flags: DescriptorFlags,
//                 modes: Modes,
//             ) -> Result<Descriptor, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = path_flags;
//                     let vec1 = path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let flags2 = open_flags;
//                     let flags3 = flags;
//                     let flags4 = modes;
//                     let ptr5 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "open-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_open-at"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         (flags2.bits() >> 0) as i32,
//                         (flags3.bits() >> 0) as i32,
//                         (flags4.bits() >> 0) as i32,
//                         ptr5,
//                     );
//                     match i32::from(*((ptr5 + 0) as *const u8)) {
//                         0 => Ok(*((ptr5 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr5 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr5 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read the contents of a symbolic link.
//             ///
//             /// If the contents contain an absolute or rooted path in the underlying
//             /// filesystem, this function fails with `error-code::not-permitted`.
//             ///
//             /// Note: This is similar to `readlinkat` in POSIX.
//             pub fn readlink_at(
//                 this: Descriptor,
//                 path: &str,
//             ) -> Result<wit_bindgen::rt::string::String, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 12]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = path;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "readlink-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_readlink-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1);
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok({
//                             let len2 = *((ptr1 + 8) as *const i32) as usize;

//                             {
//                                 #[cfg(not(debug_assertions))]
//                                 {
//                                     String::from_utf8_unchecked(Vec::from_raw_parts(
//                                         *((ptr1 + 4) as *const i32) as *mut _,
//                                         len2,
//                                         len2,
//                                     ))
//                                 }
//                                 #[cfg(debug_assertions)]
//                                 {
//                                     String::from_utf8(Vec::from_raw_parts(
//                                         *((ptr1 + 4) as *const i32) as *mut _,
//                                         len2,
//                                         len2,
//                                     ))
//                                     .unwrap()
//                                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr1 + 4) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr1 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Remove a directory.
//             ///
//             /// Return `error-code::not-empty` if the directory is not empty.
//             ///
//             /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
//             pub fn remove_directory_at(this: Descriptor, path: &str) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = path;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "remove-directory-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_remove-directory-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1);
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr1 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr1 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Rename a filesystem object.
//             ///
//             /// Note: This is similar to `renameat` in POSIX.
//             pub fn rename_at(
//                 this: Descriptor,
//                 old_path: &str,
//                 new_descriptor: Descriptor,
//                 new_path: &str,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = old_path;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let vec1 = new_path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let ptr2 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "rename-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_rename-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         ptr0,
//                         len0,
//                         wit_bindgen::rt::as_i32(new_descriptor),
//                         ptr1,
//                         len1,
//                         ptr2,
//                     );
//                     match i32::from(*((ptr2 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr2 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr2 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a symbolic link (also known as a "symlink").
//             ///
//             /// If `old-path` starts with `/`, the function fails with
//             /// `error-code::not-permitted`.
//             ///
//             /// Note: This is similar to `symlinkat` in POSIX.
//             pub fn symlink_at(
//                 this: Descriptor,
//                 old_path: &str,
//                 new_path: &str,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = old_path;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let vec1 = new_path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let ptr2 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "symlink-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_symlink-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1, len1, ptr2);
//                     match i32::from(*((ptr2 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr2 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr2 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Check accessibility of a filesystem path.
//             ///
//             /// Check whether the given filesystem path names an object which is
//             /// readable, writable, or executable, or whether it exists.
//             ///
//             /// This does not a guarantee that subsequent accesses will succeed, as
//             /// filesystem permissions may be modified asynchronously by external
//             /// entities.
//             ///
//             /// Note: This is similar to `faccessat` with the `AT_EACCESS` flag in POSIX.
//             pub fn access_at(
//                 this: Descriptor,
//                 path_flags: PathFlags,
//                 path: &str,
//                 type_: AccessType,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = path_flags;
//                     let vec1 = path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let (result3_0, result3_1) = match type_ {
//                         AccessType::Access(e) => {
//                             let flags2 = e;

//                             (0i32, (flags2.bits() >> 0) as i32)
//                         }
//                         AccessType::Exists => (1i32, 0i32),
//                     };
//                     let ptr4 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "access-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_access-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         result3_0,
//                         result3_1,
//                         ptr4,
//                     );
//                     match i32::from(*((ptr4 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr4 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr4 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Unlink a filesystem object that is not a directory.
//             ///
//             /// Return `error-code::is-directory` if the path refers to a directory.
//             /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
//             pub fn unlink_file_at(this: Descriptor, path: &str) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = path;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "unlink-file-at")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_unlink-file-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1);
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr1 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr1 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Change the permissions of a filesystem object that is not a directory.
//             ///
//             /// Note that the ultimate meanings of these permissions is
//             /// filesystem-specific.
//             ///
//             /// Note: This is similar to `fchmodat` in POSIX.
//             pub fn change_file_permissions_at(
//                 this: Descriptor,
//                 path_flags: PathFlags,
//                 path: &str,
//                 modes: Modes,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = path_flags;
//                     let vec1 = path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let flags2 = modes;
//                     let ptr3 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(
//                             target_arch = "wasm32",
//                             link_name = "change-file-permissions-at"
//                         )]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_change-file-permissions-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         (flags2.bits() >> 0) as i32,
//                         ptr3,
//                     );
//                     match i32::from(*((ptr3 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr3 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr3 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Change the permissions of a directory.
//             ///
//             /// Note that the ultimate meanings of these permissions is
//             /// filesystem-specific.
//             ///
//             /// Unlike in POSIX, the `executable` flag is not reinterpreted as a "search"
//             /// flag. `read` on a directory implies readability and searchability, and
//             /// `execute` is not valid for directories.
//             ///
//             /// Note: This is similar to `fchmodat` in POSIX.
//             pub fn change_directory_permissions_at(
//                 this: Descriptor,
//                 path_flags: PathFlags,
//                 path: &str,
//                 modes: Modes,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let flags0 = path_flags;
//                     let vec1 = path;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let flags2 = modes;
//                     let ptr3 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(
//                             target_arch = "wasm32",
//                             link_name = "change-directory-permissions-at"
//                         )]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_change-directory-permissions-at"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         (flags0.bits() >> 0) as i32,
//                         ptr1,
//                         len1,
//                         (flags2.bits() >> 0) as i32,
//                         ptr3,
//                     );
//                     match i32::from(*((ptr3 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr3 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr3 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Request a shared advisory lock for an open file.
//             ///
//             /// This requests a *shared* lock; more than one shared lock can be held for
//             /// a file at the same time.
//             ///
//             /// If the open file has an exclusive lock, this function downgrades the lock
//             /// to a shared lock. If it has a shared lock, this function has no effect.
//             ///
//             /// This requests an *advisory* lock, meaning that the file could be accessed
//             /// by other programs that don't hold the lock.
//             ///
//             /// It is unspecified how shared locks interact with locks acquired by
//             /// non-WASI programs.
//             ///
//             /// This function blocks until the lock can be acquired.
//             ///
//             /// Not all filesystems support locking; on filesystems which don't support
//             /// locking, this function returns `error-code::unsupported`.
//             ///
//             /// Note: This is similar to `flock(fd, LOCK_SH)` in Unix.
//             pub fn lock_shared(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "lock-shared")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_lock-shared"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Request an exclusive advisory lock for an open file.
//             ///
//             /// This requests an *exclusive* lock; no other locks may be held for the
//             /// file while an exclusive lock is held.
//             ///
//             /// If the open file has a shared lock and there are no exclusive locks held
//             /// for the file, this function upgrades the lock to an exclusive lock. If the
//             /// open file already has an exclusive lock, this function has no effect.
//             ///
//             /// This requests an *advisory* lock, meaning that the file could be accessed
//             /// by other programs that don't hold the lock.
//             ///
//             /// It is unspecified whether this function succeeds if the file descriptor
//             /// is not opened for writing. It is unspecified how exclusive locks interact
//             /// with locks acquired by non-WASI programs.
//             ///
//             /// This function blocks until the lock can be acquired.
//             ///
//             /// Not all filesystems support locking; on filesystems which don't support
//             /// locking, this function returns `error-code::unsupported`.
//             ///
//             /// Note: This is similar to `flock(fd, LOCK_EX)` in Unix.
//             pub fn lock_exclusive(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "lock-exclusive")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_lock-exclusive"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Request a shared advisory lock for an open file.
//             ///
//             /// This requests a *shared* lock; more than one shared lock can be held for
//             /// a file at the same time.
//             ///
//             /// If the open file has an exclusive lock, this function downgrades the lock
//             /// to a shared lock. If it has a shared lock, this function has no effect.
//             ///
//             /// This requests an *advisory* lock, meaning that the file could be accessed
//             /// by other programs that don't hold the lock.
//             ///
//             /// It is unspecified how shared locks interact with locks acquired by
//             /// non-WASI programs.
//             ///
//             /// This function returns `error-code::would-block` if the lock cannot be
//             /// acquired.
//             ///
//             /// Not all filesystems support locking; on filesystems which don't support
//             /// locking, this function returns `error-code::unsupported`.
//             ///
//             /// Note: This is similar to `flock(fd, LOCK_SH | LOCK_NB)` in Unix.
//             pub fn try_lock_shared(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "try-lock-shared")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_try-lock-shared"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Request an exclusive advisory lock for an open file.
//             ///
//             /// This requests an *exclusive* lock; no other locks may be held for the
//             /// file while an exclusive lock is held.
//             ///
//             /// If the open file has a shared lock and there are no exclusive locks held
//             /// for the file, this function upgrades the lock to an exclusive lock. If the
//             /// open file already has an exclusive lock, this function has no effect.
//             ///
//             /// This requests an *advisory* lock, meaning that the file could be accessed
//             /// by other programs that don't hold the lock.
//             ///
//             /// It is unspecified whether this function succeeds if the file descriptor
//             /// is not opened for writing. It is unspecified how exclusive locks interact
//             /// with locks acquired by non-WASI programs.
//             ///
//             /// This function returns `error-code::would-block` if the lock cannot be
//             /// acquired.
//             ///
//             /// Not all filesystems support locking; on filesystems which don't support
//             /// locking, this function returns `error-code::unsupported`.
//             ///
//             /// Note: This is similar to `flock(fd, LOCK_EX | LOCK_NB)` in Unix.
//             pub fn try_lock_exclusive(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "try-lock-exclusive")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_try-lock-exclusive"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Release a shared or exclusive lock on an open file.
//             ///
//             /// Note: This is similar to `flock(fd, LOCK_UN)` in Unix.
//             pub fn unlock(this: Descriptor) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "unlock")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_unlock"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `descriptor`, after which it may no longer
//             /// be used.
//             pub fn drop_descriptor(this: Descriptor) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-descriptor")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_drop-descriptor"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read a single directory entry from a `directory-entry-stream`.
//             pub fn read_directory_entry(
//                 this: DirectoryEntryStream,
//             ) -> Result<Option<DirectoryEntry>, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 48]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "read-directory-entry")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_read-directory-entry"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(match i32::from(*((ptr0 + 8) as *const u8)) {
//                             0 => None,
//                             1 => Some({
//                                 let len1 = *((ptr0 + 40) as *const i32) as usize;

//                                 DirectoryEntry {
//                                     inode: match i32::from(*((ptr0 + 16) as *const u8)) {
//                                         0 => None,
//                                         1 => Some(*((ptr0 + 24) as *const i64) as u64),
//                                         #[cfg(not(debug_assertions))]
//                                         _ => ::core::hint::unreachable_unchecked(),
//                                         #[cfg(debug_assertions)]
//                                         _ => panic!("invalid enum discriminant"),
//                                     },
//                                     type_: {
//                                         #[cfg(debug_assertions)]
//                                         {
//                                             match i32::from(*((ptr0 + 32) as *const u8)) {
//                                                 0 => DescriptorType::Unknown,
//                                                 1 => DescriptorType::BlockDevice,
//                                                 2 => DescriptorType::CharacterDevice,
//                                                 3 => DescriptorType::Directory,
//                                                 4 => DescriptorType::Fifo,
//                                                 5 => DescriptorType::SymbolicLink,
//                                                 6 => DescriptorType::RegularFile,
//                                                 7 => DescriptorType::Socket,
//                                                 _ => panic!("invalid enum discriminant"),
//                                             }
//                                         }
//                                         #[cfg(not(debug_assertions))]
//                                         {
//                                             ::core::mem::transmute::<_, DescriptorType>(i32::from(
//                                                 *((ptr0 + 32) as *const u8),
//                                             )
//                                                 as u8)
//                                         }
//                                     },
//                                     name: {
//                                         #[cfg(not(debug_assertions))]
//                                         {
//                                             String::from_utf8_unchecked(Vec::from_raw_parts(
//                                                 *((ptr0 + 36) as *const i32) as *mut _,
//                                                 len1,
//                                                 len1,
//                                             ))
//                                         }
//                                         #[cfg(debug_assertions)]
//                                         {
//                                             String::from_utf8(Vec::from_raw_parts(
//                                                 *((ptr0 + 36) as *const i32) as *mut _,
//                                                 len1,
//                                                 len1,
//                                             ))
//                                             .unwrap()
//                                         }
//                                     },
//                                 }
//                             }),
//                             #[cfg(not(debug_assertions))]
//                             _ => ::core::hint::unreachable_unchecked(),
//                             #[cfg(debug_assertions)]
//                             _ => panic!("invalid enum discriminant"),
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 8) as *const u8)) {
//                                     0 => ErrorCode::Access,
//                                     1 => ErrorCode::WouldBlock,
//                                     2 => ErrorCode::Already,
//                                     3 => ErrorCode::BadDescriptor,
//                                     4 => ErrorCode::Busy,
//                                     5 => ErrorCode::Deadlock,
//                                     6 => ErrorCode::Quota,
//                                     7 => ErrorCode::Exist,
//                                     8 => ErrorCode::FileTooLarge,
//                                     9 => ErrorCode::IllegalByteSequence,
//                                     10 => ErrorCode::InProgress,
//                                     11 => ErrorCode::Interrupted,
//                                     12 => ErrorCode::Invalid,
//                                     13 => ErrorCode::Io,
//                                     14 => ErrorCode::IsDirectory,
//                                     15 => ErrorCode::Loop,
//                                     16 => ErrorCode::TooManyLinks,
//                                     17 => ErrorCode::MessageSize,
//                                     18 => ErrorCode::NameTooLong,
//                                     19 => ErrorCode::NoDevice,
//                                     20 => ErrorCode::NoEntry,
//                                     21 => ErrorCode::NoLock,
//                                     22 => ErrorCode::InsufficientMemory,
//                                     23 => ErrorCode::InsufficientSpace,
//                                     24 => ErrorCode::NotDirectory,
//                                     25 => ErrorCode::NotEmpty,
//                                     26 => ErrorCode::NotRecoverable,
//                                     27 => ErrorCode::Unsupported,
//                                     28 => ErrorCode::NoTty,
//                                     29 => ErrorCode::NoSuchDevice,
//                                     30 => ErrorCode::Overflow,
//                                     31 => ErrorCode::NotPermitted,
//                                     32 => ErrorCode::Pipe,
//                                     33 => ErrorCode::ReadOnly,
//                                     34 => ErrorCode::InvalidSeek,
//                                     35 => ErrorCode::TextFileBusy,
//                                     36 => ErrorCode::CrossDevice,
//                                     _ => panic!("invalid enum discriminant"),
//                                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<_, ErrorCode>(i32::from(
//                                     *((ptr0 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `directory-entry-stream`, after which it may no longer
//             /// be used.
//             pub fn drop_directory_entry_stream(this: DirectoryEntryStream) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:filesystem/filesystem")]
//                     extern "C" {
//                         #[cfg_attr(
//                             target_arch = "wasm32",
//                             link_name = "drop-directory-entry-stream"
//                         )]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:filesystem/filesystem_drop-directory-entry-stream"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//         }
//     }
//     pub mod io {

//         #[allow(clippy::all)]
//         pub mod streams {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Pollable = super::super::super::wasi::poll::poll::Pollable;
//             /// An error type returned from a stream operation. Currently this
//             /// doesn't provide any additional information.
//             #[repr(C)]
//             #[derive(Copy, Clone)]
//             pub struct StreamError {}
//             impl ::core::fmt::Debug for StreamError {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("StreamError").finish()
//                 }
//             }
//             impl ::core::fmt::Display for StreamError {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     write!(f, "{:?}", self)
//                 }
//             }
//             impl std::error::Error for StreamError {}
//             /// An output bytestream. In the future, this will be replaced by handle
//             /// types.
//             ///
//             /// This conceptually represents a `stream<u8, _>`. It's temporary
//             /// scaffolding until component-model's async features are ready.
//             ///
//             /// `output-stream`s are *non-blocking* to the extent practical on
//             /// underlying platforms. Except where specified otherwise, I/O operations also
//             /// always return promptly, after the number of bytes that can be written
//             /// promptly, which could even be zero. To wait for the stream to be ready to
//             /// accept data, the `subscribe-to-output-stream` function to obtain a
//             /// `pollable` which can be polled for using `wasi_poll`.
//             ///
//             /// And at present, it is a `u32` instead of being an actual handle, until
//             /// the wit-bindgen implementation of handles and resources is ready.
//             ///
//             /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
//             pub type OutputStream = u32;
//             /// An input bytestream. In the future, this will be replaced by handle
//             /// types.
//             ///
//             /// This conceptually represents a `stream<u8, _>`. It's temporary
//             /// scaffolding until component-model's async features are ready.
//             ///
//             /// `input-stream`s are *non-blocking* to the extent practical on underlying
//             /// platforms. I/O operations always return promptly; if fewer bytes are
//             /// promptly available than requested, they return the number of bytes promptly
//             /// available, which could even be zero. To wait for data to be available,
//             /// use the `subscribe-to-input-stream` function to obtain a `pollable` which
//             /// can be polled for using `wasi_poll`.
//             ///
//             /// And at present, it is a `u32` instead of being an actual handle, until
//             /// the wit-bindgen implementation of handles and resources is ready.
//             ///
//             /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
//             pub type InputStream = u32;
//             #[allow(clippy::all)]
//             /// Read bytes from a stream.
//             ///
//             /// This function returns a list of bytes containing the data that was
//             /// read, along with a bool which, when true, indicates that the end of the
//             /// stream was reached. The returned list will contain up to `len` bytes; it
//             /// may return fewer than requested, but not more.
//             ///
//             /// Once a stream has reached the end, subsequent calls to read or
//             /// `skip` will always report end-of-stream rather than producing more
//             /// data.
//             ///
//             /// If `len` is 0, it represents a request to read 0 bytes, which should
//             /// always succeed, assuming the stream hasn't reached its end yet, and
//             /// return an empty list.
//             ///
//             /// The len here is a `u64`, but some callees may not be able to allocate
//             /// a buffer as large as that would imply.
//             /// FIXME: describe what happens if allocation fails.
//             pub fn read(
//                 this: InputStream,
//                 len: u64,
//             ) -> Result<(wit_bindgen::rt::vec::Vec<u8>, bool), StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "read")]
//                         #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:io/streams_read")]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             let len1 = *((ptr0 + 8) as *const i32) as usize;

//                             (
//                                 Vec::from_raw_parts(
//                                     *((ptr0 + 4) as *const i32) as *mut _,
//                                     len1,
//                                     len1,
//                                 ),
//                                 {
//                                     #[cfg(not(debug_assertions))]
//                                     {
//                                         ::core::mem::transmute::<u8, bool>(i32::from(
//                                             *((ptr0 + 12) as *const u8),
//                                         )
//                                             as u8)
//                                     }
//                                     #[cfg(debug_assertions)]
//                                     {
//                                         match i32::from(*((ptr0 + 12) as *const u8)) {
//                                             0 => false,
//                                             1 => true,
//                                             _ => panic!("invalid bool discriminant"),
//                                         }
//                                     }
//                                 },
//                             )
//                         }),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read bytes from a stream, with blocking.
//             ///
//             /// This is similar to `read`, except that it blocks until at least one
//             /// byte can be read.
//             pub fn blocking_read(
//                 this: InputStream,
//                 len: u64,
//             ) -> Result<(wit_bindgen::rt::vec::Vec<u8>, bool), StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "blocking-read")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_blocking-read"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             let len1 = *((ptr0 + 8) as *const i32) as usize;

//                             (
//                                 Vec::from_raw_parts(
//                                     *((ptr0 + 4) as *const i32) as *mut _,
//                                     len1,
//                                     len1,
//                                 ),
//                                 {
//                                     #[cfg(not(debug_assertions))]
//                                     {
//                                         ::core::mem::transmute::<u8, bool>(i32::from(
//                                             *((ptr0 + 12) as *const u8),
//                                         )
//                                             as u8)
//                                     }
//                                     #[cfg(debug_assertions)]
//                                     {
//                                         match i32::from(*((ptr0 + 12) as *const u8)) {
//                                             0 => false,
//                                             1 => true,
//                                             _ => panic!("invalid bool discriminant"),
//                                         }
//                                     }
//                                 },
//                             )
//                         }),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Skip bytes from a stream.
//             ///
//             /// This is similar to the `read` function, but avoids copying the
//             /// bytes into the instance.
//             ///
//             /// Once a stream has reached the end, subsequent calls to read or
//             /// `skip` will always report end-of-stream rather than producing more
//             /// data.
//             ///
//             /// This function returns the number of bytes skipped, along with a bool
//             /// indicating whether the end of the stream was reached. The returned
//             /// value will be at most `len`; it may be less.
//             pub fn skip(this: InputStream, len: u64) -> Result<(u64, bool), StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 24]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "skip")]
//                         #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:io/streams_skip")]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok((*((ptr0 + 8) as *const i64) as u64, {
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 16) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 16) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         })),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Skip bytes from a stream, with blocking.
//             ///
//             /// This is similar to `skip`, except that it blocks until at least one
//             /// byte can be consumed.
//             pub fn blocking_skip(this: InputStream, len: u64) -> Result<(u64, bool), StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 24]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "blocking-skip")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_blocking-skip"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok((*((ptr0 + 8) as *const i64) as u64, {
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 16) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 16) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         })),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a `pollable` which will resolve once either the specified stream
//             /// has bytes available to read or the other end of the stream has been
//             /// closed.
//             pub fn subscribe_to_input_stream(this: InputStream) -> Pollable {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "subscribe-to-input-stream")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_subscribe-to-input-stream"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     ret as u32
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `input-stream`, after which it may no longer
//             /// be used.
//             pub fn drop_input_stream(this: InputStream) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-input-stream")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_drop-input-stream"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Write bytes to a stream.
//             ///
//             /// This function returns a `u64` indicating the number of bytes from
//             /// `buf` that were written; it may be less than the full list.
//             pub fn write(this: OutputStream, buf: &[u8]) -> Result<u64, StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = buf;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "write")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_write"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1);
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok(*((ptr1 + 8) as *const i64) as u64),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Write bytes to a stream, with blocking.
//             ///
//             /// This is similar to `write`, except that it blocks until at least one
//             /// byte can be written.
//             pub fn blocking_write(this: OutputStream, buf: &[u8]) -> Result<u64, StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = buf;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "blocking-write")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_blocking-write"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0, len0, ptr1);
//                     match i32::from(*((ptr1 + 0) as *const u8)) {
//                         0 => Ok(*((ptr1 + 8) as *const i64) as u64),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Write multiple zero bytes to a stream.
//             ///
//             /// This function returns a `u64` indicating the number of zero bytes
//             /// that were written; it may be less than `len`.
//             pub fn write_zeroes(this: OutputStream, len: u64) -> Result<u64, StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "write-zeroes")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_write-zeroes"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Write multiple zero bytes to a stream, with blocking.
//             ///
//             /// This is similar to `write-zeroes`, except that it blocks until at least
//             /// one byte can be written.
//             pub fn blocking_write_zeroes(this: OutputStream, len: u64) -> Result<u64, StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "blocking-write-zeroes")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_blocking-write-zeroes"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read from one stream and write to another.
//             ///
//             /// This function returns the number of bytes transferred; it may be less
//             /// than `len`.
//             ///
//             /// Unlike other I/O functions, this function blocks until all the data
//             /// read from the input stream has been written to the output stream.
//             pub fn splice(
//                 this: OutputStream,
//                 src: InputStream,
//                 len: u64,
//             ) -> Result<(u64, bool), StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 24]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "splice")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_splice"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(src),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok((*((ptr0 + 8) as *const i64) as u64, {
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 16) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 16) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         })),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Read from one stream and write to another, with blocking.
//             ///
//             /// This is similar to `splice`, except that it blocks until at least
//             /// one byte can be read.
//             pub fn blocking_splice(
//                 this: OutputStream,
//                 src: InputStream,
//                 len: u64,
//             ) -> Result<(u64, bool), StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 24]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "blocking-splice")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_blocking-splice"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(src),
//                         wit_bindgen::rt::as_i64(len),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok((*((ptr0 + 8) as *const i64) as u64, {
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 16) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 16) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         })),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Forward the entire contents of an input stream to an output stream.
//             ///
//             /// This function repeatedly reads from the input stream and writes
//             /// the data to the output stream, until the end of the input stream
//             /// is reached, or an error is encountered.
//             ///
//             /// Unlike other I/O functions, this function blocks until the end
//             /// of the input stream is seen and all the data has been written to
//             /// the output stream.
//             ///
//             /// This function returns the number of bytes transferred.
//             pub fn forward(this: OutputStream, src: InputStream) -> Result<u64, StreamError> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "forward")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_forward"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(src),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err(StreamError {}),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a `pollable` which will resolve once either the specified stream
//             /// is ready to accept bytes or the other end of the stream has been closed.
//             pub fn subscribe_to_output_stream(this: OutputStream) -> Pollable {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(
//                             target_arch = "wasm32",
//                             link_name = "subscribe-to-output-stream"
//                         )]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_subscribe-to-output-stream"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     ret as u32
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `output-stream`, after which it may no longer
//             /// be used.
//             pub fn drop_output_stream(this: OutputStream) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:io/streams")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-output-stream")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:io/streams_drop-output-stream"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//         }
//     }
//     pub mod poll {

//         #[allow(clippy::all)]
//         pub mod poll {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             /// A "pollable" handle.
//             ///
//             /// This is conceptually represents a `stream<_, _>`, or in other words,
//             /// a stream that one can wait on, repeatedly, but which does not itself
//             /// produce any data. It's temporary scaffolding until component-model's
//             /// async features are ready.
//             ///
//             /// And at present, it is a `u32` instead of being an actual handle, until
//             /// the wit-bindgen implementation of handles and resources is ready.
//             ///
//             /// `pollable` lifetimes are not automatically managed. Users must ensure
//             /// that they do not outlive the resource they reference.
//             ///
//             /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
//             pub type Pollable = u32;
//             #[allow(clippy::all)]
//             /// Dispose of the specified `pollable`, after which it may no longer
//             /// be used.
//             pub fn drop_pollable(this: Pollable) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:poll/poll")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-pollable")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:poll/poll_drop-pollable"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Poll for completion on a set of pollables.
//             ///
//             /// The "oneoff" in the name refers to the fact that this function must do a
//             /// linear scan through the entire list of subscriptions, which may be
//             /// inefficient if the number is large and the same subscriptions are used
//             /// many times. In the future, this is expected to be obsoleted by the
//             /// component model async proposal, which will include a scalable waiting
//             /// facility.
//             ///
//             /// The result list<bool> is the same length as the argument
//             /// list<pollable>, and indicates the readiness of each corresponding
//             /// element in that / list, with true indicating ready.
//             pub fn poll_oneoff(in_: &[Pollable]) -> wit_bindgen::rt::vec::Vec<bool> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = in_;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let ptr1 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:poll/poll")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "poll-oneoff")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:poll/poll_poll-oneoff"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(ptr0, len0, ptr1);
//                     let base2 = *((ptr1 + 0) as *const i32);
//                     let len2 = *((ptr1 + 4) as *const i32);
//                     let mut result2 = Vec::with_capacity(len2 as usize);
//                     for i in 0..len2 {
//                         let base = base2 + i * 1;
//                         result2.push({
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((base + 0) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((base + 0) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         });
//                     }
//                     wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
//                     result2
//                 }
//             }
//         }
//     }
//     pub mod random {

//         #[allow(clippy::all)]
//         pub mod random {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             #[allow(clippy::all)]
//             /// Return `len` cryptographically-secure pseudo-random bytes.
//             ///
//             /// This function must produce data from an adequately seeded
//             /// cryptographically-secure pseudo-random number generator (CSPRNG), so it
//             /// must not block, from the perspective of the calling program, and the
//             /// returned data is always unpredictable.
//             ///
//             /// This function must always return fresh pseudo-random data. Deterministic
//             /// environments must omit this function, rather than implementing it with
//             /// deterministic data.
//             pub fn get_random_bytes(len: u64) -> wit_bindgen::rt::vec::Vec<u8> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:random/random")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-random-bytes")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:random/random_get-random-bytes"
//                         )]
//                         fn wit_import(_: i64, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i64(len), ptr0);
//                     let len1 = *((ptr0 + 4) as *const i32) as usize;
//                     Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1)
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return a cryptographically-secure pseudo-random `u64` value.
//             ///
//             /// This function returns the same type of pseudo-random data as
//             /// `get-random-bytes`, represented as a `u64`.
//             pub fn get_random_u64() -> u64 {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:random/random")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-random-u64")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:random/random_get-random-u64"
//                         )]
//                         fn wit_import() -> i64;
//                     }
//                     let ret = wit_import();
//                     ret as u64
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod insecure {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             #[allow(clippy::all)]
//             /// Return `len` insecure pseudo-random bytes.
//             ///
//             /// This function is not cryptographically secure. Do not use it for
//             /// anything related to security.
//             ///
//             /// There are no requirements on the values of the returned bytes, however
//             /// implementations are encouraged to return evenly distributed values with
//             /// a long period.
//             pub fn get_insecure_random_bytes(len: u64) -> wit_bindgen::rt::vec::Vec<u8> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:random/insecure")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-insecure-random-bytes")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:random/insecure_get-insecure-random-bytes"
//                         )]
//                         fn wit_import(_: i64, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i64(len), ptr0);
//                     let len1 = *((ptr0 + 4) as *const i32) as usize;
//                     Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1)
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Return an insecure pseudo-random `u64` value.
//             ///
//             /// This function returns the same type of pseudo-random data as
//             /// `get-insecure-random-bytes`, represented as a `u64`.
//             pub fn get_insecure_random_u64() -> u64 {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:random/insecure")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "get-insecure-random-u64")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:random/insecure_get-insecure-random-u64"
//                         )]
//                         fn wit_import() -> i64;
//                     }
//                     let ret = wit_import();
//                     ret as u64
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod insecure_seed {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             #[allow(clippy::all)]
//             /// Return a 128-bit value that may contain a pseudo-random value.
//             ///
//             /// The returned value is not required to be computed from a CSPRNG, and may
//             /// even be entirely deterministic. Host implementations are encouraged to
//             /// provide pseudo-random values to any program exposed to
//             /// attacker-controlled content, to enable DoS protection built into many
//             /// languages' hash-map implementations.
//             ///
//             /// This function is intended to only be called once, by a source language
//             /// to initialize Denial Of Service (DoS) protection in its hash-map
//             /// implementation.
//             ///
//             /// # Expected future evolution
//             ///
//             /// This will likely be changed to a value import, to prevent it from being
//             /// called multiple times and potentially used for purposes other than DoS
//             /// protection.
//             pub fn insecure_seed() -> (u64, u64) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:random/insecure-seed")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "insecure-seed")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:random/insecure-seed_insecure-seed"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(ptr0);
//                     (
//                         *((ptr0 + 0) as *const i64) as u64,
//                         *((ptr0 + 8) as *const i64) as u64,
//                     )
//                 }
//             }
//         }
//     }
//     pub mod sockets {

//         #[allow(clippy::all)]
//         pub mod network {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             /// An opaque resource that represents access to (a subset of) the network.
//             /// This enables context-based security for networking.
//             /// There is no need for this to map 1:1 to a physical network interface.
//             ///
//             /// FYI, In the future this will be replaced by handle types.
//             pub type Network = u32;
//             pub type Ipv6Address = (u16, u16, u16, u16, u16, u16, u16, u16);
//             #[repr(C)]
//             #[derive(Copy, Clone)]
//             pub struct Ipv6SocketAddress {
//                 pub port: u16,
//                 pub flow_info: u32,
//                 pub address: Ipv6Address,
//                 pub scope_id: u32,
//             }
//             impl ::core::fmt::Debug for Ipv6SocketAddress {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("Ipv6SocketAddress")
//                         .field("port", &self.port)
//                         .field("flow-info", &self.flow_info)
//                         .field("address", &self.address)
//                         .field("scope-id", &self.scope_id)
//                         .finish()
//                 }
//             }
//             pub type Ipv4Address = (u8, u8, u8, u8);
//             #[repr(C)]
//             #[derive(Copy, Clone)]
//             pub struct Ipv4SocketAddress {
//                 pub port: u16,
//                 pub address: Ipv4Address,
//             }
//             impl ::core::fmt::Debug for Ipv4SocketAddress {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("Ipv4SocketAddress")
//                         .field("port", &self.port)
//                         .field("address", &self.address)
//                         .finish()
//                 }
//             }
//             #[derive(Clone, Copy)]
//             pub enum IpSocketAddress {
//                 Ipv4(Ipv4SocketAddress),
//                 Ipv6(Ipv6SocketAddress),
//             }
//             impl ::core::fmt::Debug for IpSocketAddress {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         IpSocketAddress::Ipv4(e) => {
//                             f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
//                         }
//                         IpSocketAddress::Ipv6(e) => {
//                             f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
//                         }
//                     }
//                 }
//             }
//             #[repr(u8)]
//             #[derive(Clone, Copy, PartialEq, Eq)]
//             pub enum IpAddressFamily {
//                 /// Similar to `AF_INET` in POSIX.
//                 Ipv4,
//                 /// Similar to `AF_INET6` in POSIX.
//                 Ipv6,
//             }
//             impl ::core::fmt::Debug for IpAddressFamily {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         IpAddressFamily::Ipv4 => f.debug_tuple("IpAddressFamily::Ipv4").finish(),
//                         IpAddressFamily::Ipv6 => f.debug_tuple("IpAddressFamily::Ipv6").finish(),
//                     }
//                 }
//             }
//             #[derive(Clone, Copy)]
//             pub enum IpAddress {
//                 Ipv4(Ipv4Address),
//                 Ipv6(Ipv6Address),
//             }
//             impl ::core::fmt::Debug for IpAddress {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         IpAddress::Ipv4(e) => f.debug_tuple("IpAddress::Ipv4").field(e).finish(),
//                         IpAddress::Ipv6(e) => f.debug_tuple("IpAddress::Ipv6").field(e).finish(),
//                     }
//                 }
//             }
//             /// Error codes.
//             ///
//             /// In theory, every API can return any error code.
//             /// In practice, API's typically only return the errors documented per API
//             /// combined with a couple of errors that are always possible:
//             /// - `unknown`
//             /// - `access-denied`
//             /// - `not-supported`
//             /// - `out-of-memory`
//             ///
//             /// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
//             #[repr(u8)]
//             #[derive(Clone, Copy, PartialEq, Eq)]
//             pub enum ErrorCode {
//                 /// Unknown error
//                 Unknown,
//                 /// Access denied.
//                 ///
//                 /// POSIX equivalent: EACCES, EPERM
//                 AccessDenied,
//                 /// The operation is not supported.
//                 ///
//                 /// POSIX equivalent: EOPNOTSUPP
//                 NotSupported,
//                 /// Not enough memory to complete the operation.
//                 ///
//                 /// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
//                 OutOfMemory,
//                 /// The operation timed out before it could finish completely.
//                 Timeout,
//                 /// This operation is incompatible with another asynchronous operation that is already in progress.
//                 ConcurrencyConflict,
//                 /// Trying to finish an asynchronous operation that:
//                 /// - has not been started yet, or:
//                 /// - was already finished by a previous `finish-*` call.
//                 ///
//                 /// Note: this is scheduled to be removed when `future`s are natively supported.
//                 NotInProgress,
//                 /// The operation has been aborted because it could not be completed immediately.
//                 ///
//                 /// Note: this is scheduled to be removed when `future`s are natively supported.
//                 WouldBlock,
//                 /// The specified address-family is not supported.
//                 AddressFamilyNotSupported,
//                 /// An IPv4 address was passed to an IPv6 resource, or vice versa.
//                 AddressFamilyMismatch,
//                 /// The socket address is not a valid remote address. E.g. the IP address is set to INADDR_ANY, or the port is set to 0.
//                 InvalidRemoteAddress,
//                 /// The operation is only supported on IPv4 resources.
//                 Ipv4OnlyOperation,
//                 /// The operation is only supported on IPv6 resources.
//                 Ipv6OnlyOperation,
//                 /// A new socket resource could not be created because of a system limit.
//                 NewSocketLimit,
//                 /// The socket is already attached to another network.
//                 AlreadyAttached,
//                 /// The socket is already bound.
//                 AlreadyBound,
//                 /// The socket is already in the Connection state.
//                 AlreadyConnected,
//                 /// The socket is not bound to any local address.
//                 NotBound,
//                 /// The socket is not in the Connection state.
//                 NotConnected,
//                 /// A bind operation failed because the provided address is not an address that the `network` can bind to.
//                 AddressNotBindable,
//                 /// A bind operation failed because the provided address is already in use.
//                 AddressInUse,
//                 /// A bind operation failed because there are no ephemeral ports available.
//                 EphemeralPortsExhausted,
//                 /// The remote address is not reachable
//                 RemoteUnreachable,
//                 /// The socket is already in the Listener state.
//                 AlreadyListening,
//                 /// The socket is already in the Listener state.
//                 NotListening,
//                 /// The connection was forcefully rejected
//                 ConnectionRefused,
//                 /// The connection was reset.
//                 ConnectionReset,
//                 DatagramTooLarge,
//                 /// The provided name is a syntactically invalid domain name.
//                 InvalidName,
//                 /// Name does not exist or has no suitable associated IP addresses.
//                 NameUnresolvable,
//                 /// A temporary failure in name resolution occurred.
//                 TemporaryResolverFailure,
//                 /// A permanent failure in name resolution occurred.
//                 PermanentResolverFailure,
//             }
//             impl ErrorCode {
//                 pub fn name(&self) -> &'static str {
//                     match self {
//                         ErrorCode::Unknown => "unknown",
//                         ErrorCode::AccessDenied => "access-denied",
//                         ErrorCode::NotSupported => "not-supported",
//                         ErrorCode::OutOfMemory => "out-of-memory",
//                         ErrorCode::Timeout => "timeout",
//                         ErrorCode::ConcurrencyConflict => "concurrency-conflict",
//                         ErrorCode::NotInProgress => "not-in-progress",
//                         ErrorCode::WouldBlock => "would-block",
//                         ErrorCode::AddressFamilyNotSupported => "address-family-not-supported",
//                         ErrorCode::AddressFamilyMismatch => "address-family-mismatch",
//                         ErrorCode::InvalidRemoteAddress => "invalid-remote-address",
//                         ErrorCode::Ipv4OnlyOperation => "ipv4-only-operation",
//                         ErrorCode::Ipv6OnlyOperation => "ipv6-only-operation",
//                         ErrorCode::NewSocketLimit => "new-socket-limit",
//                         ErrorCode::AlreadyAttached => "already-attached",
//                         ErrorCode::AlreadyBound => "already-bound",
//                         ErrorCode::AlreadyConnected => "already-connected",
//                         ErrorCode::NotBound => "not-bound",
//                         ErrorCode::NotConnected => "not-connected",
//                         ErrorCode::AddressNotBindable => "address-not-bindable",
//                         ErrorCode::AddressInUse => "address-in-use",
//                         ErrorCode::EphemeralPortsExhausted => "ephemeral-ports-exhausted",
//                         ErrorCode::RemoteUnreachable => "remote-unreachable",
//                         ErrorCode::AlreadyListening => "already-listening",
//                         ErrorCode::NotListening => "not-listening",
//                         ErrorCode::ConnectionRefused => "connection-refused",
//                         ErrorCode::ConnectionReset => "connection-reset",
//                         ErrorCode::DatagramTooLarge => "datagram-too-large",
//                         ErrorCode::InvalidName => "invalid-name",
//                         ErrorCode::NameUnresolvable => "name-unresolvable",
//                         ErrorCode::TemporaryResolverFailure => "temporary-resolver-failure",
//                         ErrorCode::PermanentResolverFailure => "permanent-resolver-failure",
//                     }
//                 }
//                 pub fn message(&self) -> &'static str {
//                     match self {
//               ErrorCode::Unknown => "Unknown error",
//               ErrorCode::AccessDenied => "Access denied.
              
//               POSIX equivalent: EACCES, EPERM",
//               ErrorCode::NotSupported => "The operation is not supported.
              
//               POSIX equivalent: EOPNOTSUPP",
//               ErrorCode::OutOfMemory => "Not enough memory to complete the operation.
              
//               POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY",
//               ErrorCode::Timeout => "The operation timed out before it could finish completely.",
//               ErrorCode::ConcurrencyConflict => "This operation is incompatible with another asynchronous operation that is already in progress.",
//               ErrorCode::NotInProgress => "Trying to finish an asynchronous operation that:
//               - has not been started yet, or:
//               - was already finished by a previous `finish-*` call.
              
//               Note: this is scheduled to be removed when `future`s are natively supported.",
//               ErrorCode::WouldBlock => "The operation has been aborted because it could not be completed immediately.
              
//               Note: this is scheduled to be removed when `future`s are natively supported.",
//               ErrorCode::AddressFamilyNotSupported => "The specified address-family is not supported.",
//               ErrorCode::AddressFamilyMismatch => "An IPv4 address was passed to an IPv6 resource, or vice versa.",
//               ErrorCode::InvalidRemoteAddress => "The socket address is not a valid remote address. E.g. the IP address is set to INADDR_ANY, or the port is set to 0.",
//               ErrorCode::Ipv4OnlyOperation => "The operation is only supported on IPv4 resources.",
//               ErrorCode::Ipv6OnlyOperation => "The operation is only supported on IPv6 resources.",
//               ErrorCode::NewSocketLimit => "A new socket resource could not be created because of a system limit.",
//               ErrorCode::AlreadyAttached => "The socket is already attached to another network.",
//               ErrorCode::AlreadyBound => "The socket is already bound.",
//               ErrorCode::AlreadyConnected => "The socket is already in the Connection state.",
//               ErrorCode::NotBound => "The socket is not bound to any local address.",
//               ErrorCode::NotConnected => "The socket is not in the Connection state.",
//               ErrorCode::AddressNotBindable => "A bind operation failed because the provided address is not an address that the `network` can bind to.",
//               ErrorCode::AddressInUse => "A bind operation failed because the provided address is already in use.",
//               ErrorCode::EphemeralPortsExhausted => "A bind operation failed because there are no ephemeral ports available.",
//               ErrorCode::RemoteUnreachable => "The remote address is not reachable",
//               ErrorCode::AlreadyListening => "The socket is already in the Listener state.",
//               ErrorCode::NotListening => "The socket is already in the Listener state.",
//               ErrorCode::ConnectionRefused => "The connection was forcefully rejected",
//               ErrorCode::ConnectionReset => "The connection was reset.",
//               ErrorCode::DatagramTooLarge => "",
//               ErrorCode::InvalidName => "The provided name is a syntactically invalid domain name.",
//               ErrorCode::NameUnresolvable => "Name does not exist or has no suitable associated IP addresses.",
//               ErrorCode::TemporaryResolverFailure => "A temporary failure in name resolution occurred.",
//               ErrorCode::PermanentResolverFailure => "A permanent failure in name resolution occurred.",
//             }
//                 }
//             }
//             impl ::core::fmt::Debug for ErrorCode {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("ErrorCode")
//                         .field("code", &(*self as i32))
//                         .field("name", &self.name())
//                         .field("message", &self.message())
//                         .finish()
//                 }
//             }
//             impl ::core::fmt::Display for ErrorCode {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     write!(f, "{} (error {})", self.name(), *self as i32)
//                 }
//             }

//             impl std::error::Error for ErrorCode {}
//             #[allow(clippy::all)]
//             /// Dispose of the specified `network`, after which it may no longer be used.
//             ///
//             /// Note: this function is scheduled to be removed when Resources are natively supported in Wit.
//             pub fn drop_network(this: Network) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/network")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-network")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/network_drop-network"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod instance_network {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Network = super::super::super::wasi::sockets::network::Network;
//             #[allow(clippy::all)]
//             /// Get a handle to the default network.
//             pub fn instance_network() -> Network {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/instance-network")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "instance-network")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/instance-network_instance-network"
//                         )]
//                         fn wit_import() -> i32;
//                     }
//                     let ret = wit_import();
//                     ret as u32
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod ip_name_lookup {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Pollable = super::super::super::wasi::poll::poll::Pollable;
//             pub type Network = super::super::super::wasi::sockets::network::Network;
//             pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
//             pub type IpAddress = super::super::super::wasi::sockets::network::IpAddress;
//             pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
//             pub type ResolveAddressStream = u32;
//             #[allow(clippy::all)]
//             /// Resolve an internet host name to a list of IP addresses.
//             ///
//             /// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
//             ///
//             /// # Parameters
//             /// - `name`: The name to look up. IP addresses are not allowed. Unicode domain names are automatically converted
//             /// to ASCII using IDNA encoding.
//             /// - `address-family`: If provided, limit the results to addresses of this specific address family.
//             /// - `include-unavailable`: When set to true, this function will also return addresses of which the runtime
//             /// thinks (or knows) can't be connected to at the moment. For example, this will return IPv6 addresses on
//             /// systems without an active IPv6 interface. Notes:
//             /// - Even when no public IPv6 interfaces are present or active, names like "localhost" can still resolve to an IPv6 address.
//             /// - Whatever is "available" or "unavailable" is volatile and can change everytime a network cable is unplugged.
//             ///
//             /// This function never blocks. It either immediately fails or immediately returns successfully with a `resolve-address-stream`
//             /// that can be used to (asynchronously) fetch the results.
//             ///
//             /// At the moment, the stream never completes successfully with 0 items. Ie. the first call
//             /// to `resolve-next-address` never returns `ok(none)`. This may change in the future.
//             ///
//             /// # Typical errors
//             /// - `invalid-name`:                 `name` is a syntactically invalid domain name.
//             /// - `invalid-name`:                 `name` is an IP address.
//             /// - `address-family-not-supported`: The specified `address-family` is not supported. (EAI_FAMILY)
//             ///
//             /// # References:
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
//             /// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
//             pub fn resolve_addresses(
//                 network: Network,
//                 name: &str,
//                 address_family: Option<IpAddressFamily>,
//                 include_unavailable: bool,
//             ) -> Result<ResolveAddressStream, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let vec0 = name;
//                     let ptr0 = vec0.as_ptr() as i32;
//                     let len0 = vec0.len() as i32;
//                     let (result1_0,result1_1,) = match address_family {
//                 Some(e) => (1i32, match e {
//                   super::super::super::wasi::sockets::network::IpAddressFamily::Ipv4 => 0,
//                   super::super::super::wasi::sockets::network::IpAddressFamily::Ipv6 => 1,
//                 }),
//                 None => {
//                   (0i32, 0i32)
//                 },
//               };
//                     let ptr2 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/ip-name-lookup")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "resolve-addresses")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/ip-name-lookup_resolve-addresses"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(network),
//                         ptr0,
//                         len0,
//                         result1_0,
//                         result1_1,
//                         match include_unavailable {
//                             true => 1,
//                             false => 0,
//                         },
//                         ptr2,
//                     );
//                     match i32::from(*((ptr2 + 0) as *const u8)) {
//                         0 => Ok(*((ptr2 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr2 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr2 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Returns the next address from the resolver.
//             ///
//             /// This function should be called multiple times. On each call, it will
//             /// return the next address in connection order preference. If all
//             /// addresses have been exhausted, this function returns `none`.
//             /// After which, you should release the stream with `drop-resolve-address-stream`.
//             ///
//             /// This function never returns IPv4-mapped IPv6 addresses.
//             ///
//             /// # Typical errors
//             /// - `name-unresolvable`:          Name does not exist or has no suitable associated IP addresses. (EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY)
//             /// - `temporary-resolver-failure`: A temporary failure in name resolution occurred. (EAI_AGAIN)
//             /// - `permanent-resolver-failure`: A permanent failure in name resolution occurred. (EAI_FAIL)
//             /// - `would-block`:                A result is not available yet. (EWOULDBLOCK, EAGAIN)
//             pub fn resolve_next_address(
//                 this: ResolveAddressStream,
//             ) -> Result<Option<IpAddress>, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(2))]
//                     struct RetArea([u8; 22]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/ip-name-lookup")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "resolve-next-address")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/ip-name-lookup_resolve-next-address"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(match i32::from(*((ptr0 + 2) as *const u8)) {
//                             0 => None,
//                             1 => Some({
//                                 {
//                                     match i32::from(*((ptr0 + 4) as *const u8)) {
//                     0 => super::super::super::wasi::sockets::network::IpAddress::Ipv4((i32::from(*((ptr0 + 6) as *const u8)) as u8, i32::from(*((ptr0 + 7) as *const u8)) as u8, i32::from(*((ptr0 + 8) as *const u8)) as u8, i32::from(*((ptr0 + 9) as *const u8)) as u8)),
//                     #[cfg(debug_assertions)]1 => super::super::super::wasi::sockets::network::IpAddress::Ipv6((i32::from(*((ptr0 + 6) as *const u16)) as u16, i32::from(*((ptr0 + 8) as *const u16)) as u16, i32::from(*((ptr0 + 10) as *const u16)) as u16, i32::from(*((ptr0 + 12) as *const u16)) as u16, i32::from(*((ptr0 + 14) as *const u16)) as u16, i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16)),
//                     #[cfg(not(debug_assertions))]_ => super::super::super::wasi::sockets::network::IpAddress::Ipv6((i32::from(*((ptr0 + 6) as *const u16)) as u16, i32::from(*((ptr0 + 8) as *const u16)) as u16, i32::from(*((ptr0 + 10) as *const u16)) as u16, i32::from(*((ptr0 + 12) as *const u16)) as u16, i32::from(*((ptr0 + 14) as *const u16)) as u16, i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16)),
//                     #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
//                   }
//                                 }
//                             }),
//                             #[cfg(not(debug_assertions))]
//                             _ => ::core::hint::unreachable_unchecked(),
//                             #[cfg(debug_assertions)]
//                             _ => panic!("invalid enum discriminant"),
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 2) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 2) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `resolve-address-stream`, after which it may no longer be used.
//             ///
//             /// Note: this function is scheduled to be removed when Resources are natively supported in Wit.
//             pub fn drop_resolve_address_stream(this: ResolveAddressStream) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/ip-name-lookup")]
//                     extern "C" {
//                         #[cfg_attr(
//                             target_arch = "wasm32",
//                             link_name = "drop-resolve-address-stream"
//                         )]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/ip-name-lookup_drop-resolve-address-stream"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a `pollable` which will resolve once the stream is ready for I/O.
//             ///
//             /// Note: this function is here for WASI Preview2 only.
//             /// It's planned to be removed when `future` is natively supported in Preview3.
//             pub fn subscribe(this: ResolveAddressStream) -> Pollable {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/ip-name-lookup")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/ip-name-lookup_subscribe"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     ret as u32
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod tcp {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type InputStream = super::super::super::wasi::io::streams::InputStream;
//             pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
//             pub type Pollable = super::super::super::wasi::poll::poll::Pollable;
//             pub type Network = super::super::super::wasi::sockets::network::Network;
//             pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
//             pub type IpSocketAddress = super::super::super::wasi::sockets::network::IpSocketAddress;
//             pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
//             /// A TCP socket handle.
//             pub type TcpSocket = u32;
//             #[repr(u8)]
//             #[derive(Clone, Copy, PartialEq, Eq)]
//             pub enum ShutdownType {
//                 /// Similar to `SHUT_RD` in POSIX.
//                 Receive,
//                 /// Similar to `SHUT_WR` in POSIX.
//                 Send,
//                 /// Similar to `SHUT_RDWR` in POSIX.
//                 Both,
//             }
//             impl ::core::fmt::Debug for ShutdownType {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     match self {
//                         ShutdownType::Receive => f.debug_tuple("ShutdownType::Receive").finish(),
//                         ShutdownType::Send => f.debug_tuple("ShutdownType::Send").finish(),
//                         ShutdownType::Both => f.debug_tuple("ShutdownType::Both").finish(),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Bind the socket to a specific network on the provided IP address and port.
//             ///
//             /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
//             /// network interface(s) to bind to.
//             /// If the TCP/UDP port is zero, the socket will be bound to a random free port.
//             ///
//             /// When a socket is not explicitly bound, the first invocation to a listen or connect operation will
//             /// implicitly bind the socket.
//             ///
//             /// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
//             ///
//             /// # Typical `start` errors
//             /// - `address-family-mismatch`:   The `local-address` has the wrong address family. (EINVAL)
//             /// - `already-bound`:             The socket is already bound. (EINVAL)
//             /// - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             ///
//             /// # Typical `finish` errors
//             /// - `ephemeral-ports-exhausted`: No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
//             /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
//             /// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
//             /// - `not-in-progress`:           A `bind` operation is not in progress.
//             /// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
//             /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
//             pub fn start_bind(
//                 this: TcpSocket,
//                 network: Network,
//                 local_address: IpSocketAddress,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let (
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                     ) = match local_address {
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
//                                 port: port0,
//                                 address: address0,
//                             } = e;
//                             let (t1_0, t1_1, t1_2, t1_3) = address0;

//                             (
//                                 0i32,
//                                 wit_bindgen::rt::as_i32(port0),
//                                 wit_bindgen::rt::as_i32(t1_0),
//                                 wit_bindgen::rt::as_i32(t1_1),
//                                 wit_bindgen::rt::as_i32(t1_2),
//                                 wit_bindgen::rt::as_i32(t1_3),
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                             )
//                         }
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
//                                 port: port2,
//                                 flow_info: flow_info2,
//                                 address: address2,
//                                 scope_id: scope_id2,
//                             } = e;
//                             let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;

//                             (
//                                 1i32,
//                                 wit_bindgen::rt::as_i32(port2),
//                                 wit_bindgen::rt::as_i32(flow_info2),
//                                 wit_bindgen::rt::as_i32(t3_0),
//                                 wit_bindgen::rt::as_i32(t3_1),
//                                 wit_bindgen::rt::as_i32(t3_2),
//                                 wit_bindgen::rt::as_i32(t3_3),
//                                 wit_bindgen::rt::as_i32(t3_4),
//                                 wit_bindgen::rt::as_i32(t3_5),
//                                 wit_bindgen::rt::as_i32(t3_6),
//                                 wit_bindgen::rt::as_i32(t3_7),
//                                 wit_bindgen::rt::as_i32(scope_id2),
//                             )
//                         }
//                     };
//                     let ptr5 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "start-bind")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_start-bind"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(network),
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                         ptr5,
//                     );
//                     match i32::from(*((ptr5 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr5 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr5 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn finish_bind(this: TcpSocket) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "finish-bind")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_finish-bind"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Connect to a remote endpoint.
//             ///
//             /// On success:
//             /// - the socket is transitioned into the Connection state
//             /// - a pair of streams is returned that can be used to read & write to the connection
//             ///
//             /// # Typical `start` errors
//             /// - `address-family-mismatch`:   The `remote-address` has the wrong address family. (EAFNOSUPPORT)
//             /// - `invalid-remote-address`:    The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
//             /// - `invalid-remote-address`:    The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
//             /// - `already-attached`:          The socket is already attached to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
//             /// - `already-connected`:         The socket is already in the Connection state. (EISCONN)
//             /// - `already-listening`:         The socket is already in the Listener state. (EOPNOTSUPP, EINVAL on Windows)
//             /// - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             ///
//             /// # Typical `finish` errors
//             /// - `timeout`:                   Connection timed out. (ETIMEDOUT)
//             /// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
//             /// - `connection-reset`:          The connection was reset. (ECONNRESET)
//             /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
//             /// - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
//             /// - `not-in-progress`:           A `connect` operation is not in progress.
//             /// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
//             /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
//             /// - <https://man.freebsd.org/cgi/man.cgi?connect>
//             pub fn start_connect(
//                 this: TcpSocket,
//                 network: Network,
//                 remote_address: IpSocketAddress,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let (
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                     ) = match remote_address {
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
//                                 port: port0,
//                                 address: address0,
//                             } = e;
//                             let (t1_0, t1_1, t1_2, t1_3) = address0;

//                             (
//                                 0i32,
//                                 wit_bindgen::rt::as_i32(port0),
//                                 wit_bindgen::rt::as_i32(t1_0),
//                                 wit_bindgen::rt::as_i32(t1_1),
//                                 wit_bindgen::rt::as_i32(t1_2),
//                                 wit_bindgen::rt::as_i32(t1_3),
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                             )
//                         }
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
//                                 port: port2,
//                                 flow_info: flow_info2,
//                                 address: address2,
//                                 scope_id: scope_id2,
//                             } = e;
//                             let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;

//                             (
//                                 1i32,
//                                 wit_bindgen::rt::as_i32(port2),
//                                 wit_bindgen::rt::as_i32(flow_info2),
//                                 wit_bindgen::rt::as_i32(t3_0),
//                                 wit_bindgen::rt::as_i32(t3_1),
//                                 wit_bindgen::rt::as_i32(t3_2),
//                                 wit_bindgen::rt::as_i32(t3_3),
//                                 wit_bindgen::rt::as_i32(t3_4),
//                                 wit_bindgen::rt::as_i32(t3_5),
//                                 wit_bindgen::rt::as_i32(t3_6),
//                                 wit_bindgen::rt::as_i32(t3_7),
//                                 wit_bindgen::rt::as_i32(scope_id2),
//                             )
//                         }
//                     };
//                     let ptr5 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "start-connect")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_start-connect"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(network),
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                         ptr5,
//                     );
//                     match i32::from(*((ptr5 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr5 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr5 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn finish_connect(
//                 this: TcpSocket,
//             ) -> Result<(InputStream, OutputStream), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 12]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "finish-connect")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_finish-connect"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok((
//                             *((ptr0 + 4) as *const i32) as u32,
//                             *((ptr0 + 8) as *const i32) as u32,
//                         )),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Start listening for new connections.
//             ///
//             /// Transitions the socket into the Listener state.
//             ///
//             /// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
//             ///
//             /// # Typical `start` errors
//             /// - `already-attached`:          The socket is already attached to a different network. The `network` passed to `listen` must be identical to the one passed to `bind`.
//             /// - `already-connected`:         The socket is already in the Connection state. (EISCONN, EINVAL on BSD)
//             /// - `already-listening`:         The socket is already in the Listener state.
//             /// - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EINVAL on BSD)
//             ///
//             /// # Typical `finish` errors
//             /// - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
//             /// - `not-in-progress`:           A `listen` operation is not in progress.
//             /// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
//             /// - <https://man7.org/linux/man-pages/man2/listen.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
//             pub fn start_listen(this: TcpSocket, network: Network) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "start-listen")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_start-listen"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(network),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn finish_listen(this: TcpSocket) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "finish-listen")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_finish-listen"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Accept a new client socket.
//             ///
//             /// The returned socket is bound and in the Connection state.
//             ///
//             /// On success, this function returns the newly accepted client socket along with
//             /// a pair of streams that can be used to read & write to the connection.
//             ///
//             /// # Typical errors
//             /// - `not-listening`: Socket is not in the Listener state. (EINVAL)
//             /// - `would-block`:   No pending connections at the moment. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// Host implementations must skip over transient errors returned by the native accept syscall.
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
//             /// - <https://man7.org/linux/man-pages/man2/accept.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
//             pub fn accept(
//                 this: TcpSocket,
//             ) -> Result<(TcpSocket, InputStream, OutputStream), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "accept")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_accept"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok((
//                             *((ptr0 + 4) as *const i32) as u32,
//                             *((ptr0 + 8) as *const i32) as u32,
//                             *((ptr0 + 12) as *const i32) as u32,
//                         )),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get the bound local address.
//             ///
//             /// # Typical errors
//             /// - `not-bound`: The socket is not bound to any local address.
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
//             /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
//             /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
//             pub fn local_address(this: TcpSocket) -> Result<IpSocketAddress, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 36]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "local-address")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_local-address"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(super::super::super::wasi::sockets::network::Ipv4SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, address:(i32::from(*((ptr0 + 10) as *const u8)) as u8, i32::from(*((ptr0 + 11) as *const u8)) as u8, i32::from(*((ptr0 + 12) as *const u8)) as u8, i32::from(*((ptr0 + 13) as *const u8)) as u8), }),
//                   #[cfg(debug_assertions)]1 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(not(debug_assertions))]_ => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get the bound remote address.
//             ///
//             /// # Typical errors
//             /// - `not-connected`: The socket is not connected to a remote address. (ENOTCONN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
//             /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
//             pub fn remote_address(this: TcpSocket) -> Result<IpSocketAddress, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 36]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "remote-address")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_remote-address"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(super::super::super::wasi::sockets::network::Ipv4SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, address:(i32::from(*((ptr0 + 10) as *const u8)) as u8, i32::from(*((ptr0 + 11) as *const u8)) as u8, i32::from(*((ptr0 + 12) as *const u8)) as u8, i32::from(*((ptr0 + 13) as *const u8)) as u8), }),
//                   #[cfg(debug_assertions)]1 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(not(debug_assertions))]_ => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Whether this is a IPv4 or IPv6 socket.
//             ///
//             /// Equivalent to the SO_DOMAIN socket option.
//             pub fn address_family(this: TcpSocket) -> IpAddressFamily {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "address-family")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_address-family"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     {
//                         #[cfg(debug_assertions)]
//                         {
//                             match ret {
//                 0 => super::super::super::wasi::sockets::network::IpAddressFamily::Ipv4,
//                 1 => super::super::super::wasi::sockets::network::IpAddressFamily::Ipv6,
//                 _ => panic!("invalid enum discriminant"),
//               }
//                         }
//                         #[cfg(not(debug_assertions))]
//                         {
//                             ::core::mem::transmute::<
//                                 _,
//                                 super::super::super::wasi::sockets::network::IpAddressFamily,
//                             >(ret as u8)
//                         }
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Whether IPv4 compatibility (dual-stack) mode is disabled or not.
//             ///
//             /// Equivalent to the IPV6_V6ONLY socket option.
//             ///
//             /// # Typical errors
//             /// - `ipv6-only-operation`:  (get/set) `this` socket is an IPv4 socket.
//             /// - `already-bound`:        (set) The socket is already bound.
//             /// - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)
//             /// - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             pub fn ipv6_only(this: TcpSocket) -> Result<bool, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "ipv6-only")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_ipv6-only"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_ipv6_only(this: TcpSocket, value: bool) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-ipv6-only")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-ipv6-only"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         match value {
//                             true => 1,
//                             false => 0,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Hints the desired listen queue size. Implementations are free to ignore this.
//             ///
//             /// # Typical errors
//             /// - `already-connected`:    (set) The socket is already in the Connection state.
//             /// - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             pub fn set_listen_backlog_size(this: TcpSocket, value: u64) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-listen-backlog-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-listen-backlog-size"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Equivalent to the SO_KEEPALIVE socket option.
//             ///
//             /// # Typical errors
//             /// - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             pub fn keep_alive(this: TcpSocket) -> Result<bool, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "keep-alive")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_keep-alive"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_keep_alive(this: TcpSocket, value: bool) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-keep-alive")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-keep-alive"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         match value {
//                             true => 1,
//                             false => 0,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Equivalent to the TCP_NODELAY socket option.
//             ///
//             /// # Typical errors
//             /// - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             pub fn no_delay(this: TcpSocket) -> Result<bool, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "no-delay")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_no-delay"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_no_delay(this: TcpSocket, value: bool) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-no-delay")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-no-delay"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         match value {
//                             true => 1,
//                             false => 0,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
//             ///
//             /// # Typical errors
//             /// - `already-connected`:    (set) The socket is already in the Connection state.
//             /// - `already-listening`:    (set) The socket is already in the Listener state.
//             /// - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             pub fn unicast_hop_limit(this: TcpSocket) -> Result<u8, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "unicast-hop-limit")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_unicast-hop-limit"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(i32::from(*((ptr0 + 1) as *const u8)) as u8),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_unicast_hop_limit(this: TcpSocket, value: u8) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-unicast-hop-limit")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-unicast-hop-limit"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// The kernel buffer space reserved for sends/receives on this socket.
//             ///
//             /// Note #1: an implementation may choose to cap or round the buffer size when setting the value.
//             /// In other words, after setting a value, reading the same setting back may return a different value.
//             ///
//             /// Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of
//             /// actual data to be sent/received by the application, because the kernel might also use the buffer space
//             /// for internal metadata structures.
//             ///
//             /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
//             ///
//             /// # Typical errors
//             /// - `already-connected`:    (set) The socket is already in the Connection state.
//             /// - `already-listening`:    (set) The socket is already in the Listener state.
//             /// - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)
//             pub fn receive_buffer_size(this: TcpSocket) -> Result<u64, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "receive-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_receive-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 8) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_receive_buffer_size(this: TcpSocket, value: u64) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-receive-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-receive-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn send_buffer_size(this: TcpSocket) -> Result<u64, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "send-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_send-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 8) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_send_buffer_size(this: TcpSocket, value: u64) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-send-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_set-send-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a `pollable` which will resolve once the socket is ready for I/O.
//             ///
//             /// Note: this function is here for WASI Preview2 only.
//             /// It's planned to be removed when `future` is natively supported in Preview3.
//             pub fn subscribe(this: TcpSocket) -> Pollable {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_subscribe"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     ret as u32
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Initiate a graceful shutdown.
//             ///
//             /// - receive: the socket is not expecting to receive any more data from the peer. All subsequent read
//             /// operations on the `input-stream` associated with this socket will return an End Of Stream indication.
//             /// Any data still in the receive queue at time of calling `shutdown` will be discarded.
//             /// - send: the socket is not expecting to send any more data to the peer. All subsequent write
//             /// operations on the `output-stream` associated with this socket will return an error.
//             /// - both: same effect as receive & send combined.
//             ///
//             /// The shutdown function does not close (drop) the socket.
//             ///
//             /// # Typical errors
//             /// - `not-connected`: The socket is not in the Connection state. (ENOTCONN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>
//             /// - <https://man7.org/linux/man-pages/man2/shutdown.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>
//             pub fn shutdown(this: TcpSocket, shutdown_type: ShutdownType) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "shutdown")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_shutdown"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         match shutdown_type {
//                             ShutdownType::Receive => 0,
//                             ShutdownType::Send => 1,
//                             ShutdownType::Both => 2,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `tcp-socket`, after which it may no longer be used.
//             ///
//             /// Similar to the POSIX `close` function.
//             ///
//             /// Note: this function is scheduled to be removed when Resources are natively supported in Wit.
//             pub fn drop_tcp_socket(this: TcpSocket) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/tcp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-tcp-socket")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp_drop-tcp-socket"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod tcp_create_socket {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
//             pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
//             pub type TcpSocket = super::super::super::wasi::sockets::tcp::TcpSocket;
//             #[allow(clippy::all)]
//             /// Create a new TCP socket.
//             ///
//             /// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
//             ///
//             /// This function does not require a network capability handle. This is considered to be safe because
//             /// at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind`/`listen`/`connect`
//             /// is called, the socket is effectively an in-memory configuration object, unable to communicate with the outside world.
//             ///
//             /// All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
//             ///
//             /// # Typical errors
//             /// - `not-supported`:                The host does not support TCP sockets. (EOPNOTSUPP)
//             /// - `address-family-not-supported`: The specified `address-family` is not supported. (EAFNOSUPPORT)
//             /// - `new-socket-limit`:             The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
//             /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
//             pub fn create_tcp_socket(
//                 address_family: IpAddressFamily,
//             ) -> Result<TcpSocket, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/tcp-create-socket")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "create-tcp-socket")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/tcp-create-socket_create-tcp-socket"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(
//                         match address_family {
//                             super::super::super::wasi::sockets::network::IpAddressFamily::Ipv4 => 0,
//                             super::super::super::wasi::sockets::network::IpAddressFamily::Ipv6 => 1,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod udp {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type Pollable = super::super::super::wasi::poll::poll::Pollable;
//             pub type Network = super::super::super::wasi::sockets::network::Network;
//             pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
//             pub type IpSocketAddress = super::super::super::wasi::sockets::network::IpSocketAddress;
//             pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
//             /// A UDP socket handle.
//             pub type UdpSocket = u32;
//             #[derive(Clone)]
//             pub struct Datagram {
//                 pub data: wit_bindgen::rt::vec::Vec<u8>,
//                 pub remote_address: IpSocketAddress,
//             }
//             impl ::core::fmt::Debug for Datagram {
//                 fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
//                     f.debug_struct("Datagram")
//                         .field("data", &self.data)
//                         .field("remote-address", &self.remote_address)
//                         .finish()
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Bind the socket to a specific network on the provided IP address and port.
//             ///
//             /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
//             /// network interface(s) to bind to.
//             /// If the TCP/UDP port is zero, the socket will be bound to a random free port.
//             ///
//             /// When a socket is not explicitly bound, the first invocation to connect will implicitly bind the socket.
//             ///
//             /// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
//             ///
//             /// # Typical `start` errors
//             /// - `address-family-mismatch`:   The `local-address` has the wrong address family. (EINVAL)
//             /// - `already-bound`:             The socket is already bound. (EINVAL)
//             /// - `concurrency-conflict`:      Another `bind` or `connect` operation is already in progress. (EALREADY)
//             ///
//             /// # Typical `finish` errors
//             /// - `ephemeral-ports-exhausted`: No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
//             /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
//             /// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
//             /// - `not-in-progress`:           A `bind` operation is not in progress.
//             /// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
//             /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
//             pub fn start_bind(
//                 this: UdpSocket,
//                 network: Network,
//                 local_address: IpSocketAddress,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let (
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                     ) = match local_address {
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
//                                 port: port0,
//                                 address: address0,
//                             } = e;
//                             let (t1_0, t1_1, t1_2, t1_3) = address0;

//                             (
//                                 0i32,
//                                 wit_bindgen::rt::as_i32(port0),
//                                 wit_bindgen::rt::as_i32(t1_0),
//                                 wit_bindgen::rt::as_i32(t1_1),
//                                 wit_bindgen::rt::as_i32(t1_2),
//                                 wit_bindgen::rt::as_i32(t1_3),
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                             )
//                         }
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
//                                 port: port2,
//                                 flow_info: flow_info2,
//                                 address: address2,
//                                 scope_id: scope_id2,
//                             } = e;
//                             let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;

//                             (
//                                 1i32,
//                                 wit_bindgen::rt::as_i32(port2),
//                                 wit_bindgen::rt::as_i32(flow_info2),
//                                 wit_bindgen::rt::as_i32(t3_0),
//                                 wit_bindgen::rt::as_i32(t3_1),
//                                 wit_bindgen::rt::as_i32(t3_2),
//                                 wit_bindgen::rt::as_i32(t3_3),
//                                 wit_bindgen::rt::as_i32(t3_4),
//                                 wit_bindgen::rt::as_i32(t3_5),
//                                 wit_bindgen::rt::as_i32(t3_6),
//                                 wit_bindgen::rt::as_i32(t3_7),
//                                 wit_bindgen::rt::as_i32(scope_id2),
//                             )
//                         }
//                     };
//                     let ptr5 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "start-bind")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_start-bind"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(network),
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                         ptr5,
//                     );
//                     match i32::from(*((ptr5 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr5 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr5 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn finish_bind(this: UdpSocket) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "finish-bind")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_finish-bind"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Set the destination address.
//             ///
//             /// The local-address is updated based on the best network path to `remote-address`.
//             ///
//             /// When a destination address is set:
//             /// - all receive operations will only return datagrams sent from the provided `remote-address`.
//             /// - the `send` function can only be used to send to this destination.
//             ///
//             /// Note that this function does not generate any network traffic and the peer is not aware of this "connection".
//             ///
//             /// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
//             ///
//             /// # Typical `start` errors
//             /// - `address-family-mismatch`:   The `remote-address` has the wrong address family. (EAFNOSUPPORT)
//             /// - `invalid-remote-address`:    The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
//             /// - `invalid-remote-address`:    The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
//             /// - `already-attached`:          The socket is already bound to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
//             /// - `concurrency-conflict`:      Another `bind` or `connect` operation is already in progress. (EALREADY)
//             ///
//             /// # Typical `finish` errors
//             /// - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
//             /// - `not-in-progress`:           A `connect` operation is not in progress.
//             /// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
//             /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
//             /// - <https://man.freebsd.org/cgi/man.cgi?connect>
//             pub fn start_connect(
//                 this: UdpSocket,
//                 network: Network,
//                 remote_address: IpSocketAddress,
//             ) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let (
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                     ) = match remote_address {
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
//                                 port: port0,
//                                 address: address0,
//                             } = e;
//                             let (t1_0, t1_1, t1_2, t1_3) = address0;

//                             (
//                                 0i32,
//                                 wit_bindgen::rt::as_i32(port0),
//                                 wit_bindgen::rt::as_i32(t1_0),
//                                 wit_bindgen::rt::as_i32(t1_1),
//                                 wit_bindgen::rt::as_i32(t1_2),
//                                 wit_bindgen::rt::as_i32(t1_3),
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                             )
//                         }
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
//                                 port: port2,
//                                 flow_info: flow_info2,
//                                 address: address2,
//                                 scope_id: scope_id2,
//                             } = e;
//                             let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;

//                             (
//                                 1i32,
//                                 wit_bindgen::rt::as_i32(port2),
//                                 wit_bindgen::rt::as_i32(flow_info2),
//                                 wit_bindgen::rt::as_i32(t3_0),
//                                 wit_bindgen::rt::as_i32(t3_1),
//                                 wit_bindgen::rt::as_i32(t3_2),
//                                 wit_bindgen::rt::as_i32(t3_3),
//                                 wit_bindgen::rt::as_i32(t3_4),
//                                 wit_bindgen::rt::as_i32(t3_5),
//                                 wit_bindgen::rt::as_i32(t3_6),
//                                 wit_bindgen::rt::as_i32(t3_7),
//                                 wit_bindgen::rt::as_i32(scope_id2),
//                             )
//                         }
//                     };
//                     let ptr5 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "start-connect")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_start-connect"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(network),
//                         result4_0,
//                         result4_1,
//                         result4_2,
//                         result4_3,
//                         result4_4,
//                         result4_5,
//                         result4_6,
//                         result4_7,
//                         result4_8,
//                         result4_9,
//                         result4_10,
//                         result4_11,
//                         ptr5,
//                     );
//                     match i32::from(*((ptr5 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr5 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr5 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn finish_connect(this: UdpSocket) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "finish-connect")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_finish-connect"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Receive a message.
//             ///
//             /// Returns:
//             /// - The sender address of the datagram
//             /// - The number of bytes read.
//             ///
//             /// # Typical errors
//             /// - `not-bound`:          The socket is not bound to any local address. (EINVAL)
//             /// - `remote-unreachable`: The remote address is not reachable. (ECONNREFUSED, ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
//             /// - `would-block`:        There is no pending data available to be read at the moment. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
//             /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
//             /// - <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
//             pub fn receive(this: UdpSocket) -> Result<Datagram, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 44]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "receive")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_receive"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             let len1 = *((ptr0 + 8) as *const i32) as usize;

//                             Datagram {
//                                 data: Vec::from_raw_parts(
//                                     *((ptr0 + 4) as *const i32) as *mut _,
//                                     len1,
//                                     len1,
//                                 ),
//                                 remote_address: {
//                                     {
//                                         match i32::from(*((ptr0 + 12) as *const u8)) {
//                     0 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(super::super::super::wasi::sockets::network::Ipv4SocketAddress{port:i32::from(*((ptr0 + 16) as *const u16)) as u16, address:(i32::from(*((ptr0 + 18) as *const u8)) as u8, i32::from(*((ptr0 + 19) as *const u8)) as u8, i32::from(*((ptr0 + 20) as *const u8)) as u8, i32::from(*((ptr0 + 21) as *const u8)) as u8), }),
//                     #[cfg(debug_assertions)]1 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 16) as *const u16)) as u16, flow_info:*((ptr0 + 20) as *const i32) as u32, address:(i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16, i32::from(*((ptr0 + 32) as *const u16)) as u16, i32::from(*((ptr0 + 34) as *const u16)) as u16, i32::from(*((ptr0 + 36) as *const u16)) as u16, i32::from(*((ptr0 + 38) as *const u16)) as u16), scope_id:*((ptr0 + 40) as *const i32) as u32, }),
//                     #[cfg(not(debug_assertions))]_ => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 16) as *const u16)) as u16, flow_info:*((ptr0 + 20) as *const i32) as u32, address:(i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16, i32::from(*((ptr0 + 32) as *const u16)) as u16, i32::from(*((ptr0 + 34) as *const u16)) as u16, i32::from(*((ptr0 + 36) as *const u16)) as u16, i32::from(*((ptr0 + 38) as *const u16)) as u16), scope_id:*((ptr0 + 40) as *const i32) as u32, }),
//                     #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
//                   }
//                                     }
//                                 },
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Send a message to a specific destination address.
//             ///
//             /// The remote address option is required. To send a message to the "connected" peer,
//             /// call `remote-address` to get their address.
//             ///
//             /// # Typical errors
//             /// - `address-family-mismatch`: The `remote-address` has the wrong address family. (EAFNOSUPPORT)
//             /// - `invalid-remote-address`:  The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
//             /// - `invalid-remote-address`:  The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
//             /// - `already-connected`:       The socket is in "connected" mode and the `datagram.remote-address` does not match the address passed to `connect`. (EISCONN)
//             /// - `not-bound`:               The socket is not bound to any local address. Unlike POSIX, this function does not perform an implicit bind.
//             /// - `remote-unreachable`:      The remote address is not reachable. (ECONNREFUSED, ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
//             /// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
//             /// - `would-block`:             The send buffer is currently full. (EWOULDBLOCK, EAGAIN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
//             /// - <https://man7.org/linux/man-pages/man2/send.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
//             pub fn send(this: UdpSocket, datagram: &Datagram) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let Datagram {
//                         data: data0,
//                         remote_address: remote_address0,
//                     } = datagram;
//                     let vec1 = data0;
//                     let ptr1 = vec1.as_ptr() as i32;
//                     let len1 = vec1.len() as i32;
//                     let (
//                         result6_0,
//                         result6_1,
//                         result6_2,
//                         result6_3,
//                         result6_4,
//                         result6_5,
//                         result6_6,
//                         result6_7,
//                         result6_8,
//                         result6_9,
//                         result6_10,
//                         result6_11,
//                     ) = match remote_address0 {
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
//                                 port: port2,
//                                 address: address2,
//                             } = e;
//                             let (t3_0, t3_1, t3_2, t3_3) = address2;

//                             (
//                                 0i32,
//                                 wit_bindgen::rt::as_i32(port2),
//                                 wit_bindgen::rt::as_i32(t3_0),
//                                 wit_bindgen::rt::as_i32(t3_1),
//                                 wit_bindgen::rt::as_i32(t3_2),
//                                 wit_bindgen::rt::as_i32(t3_3),
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                                 0i32,
//                             )
//                         }
//                         super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(e) => {
//                             let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
//                                 port: port4,
//                                 flow_info: flow_info4,
//                                 address: address4,
//                                 scope_id: scope_id4,
//                             } = e;
//                             let (t5_0, t5_1, t5_2, t5_3, t5_4, t5_5, t5_6, t5_7) = address4;

//                             (
//                                 1i32,
//                                 wit_bindgen::rt::as_i32(port4),
//                                 wit_bindgen::rt::as_i32(flow_info4),
//                                 wit_bindgen::rt::as_i32(t5_0),
//                                 wit_bindgen::rt::as_i32(t5_1),
//                                 wit_bindgen::rt::as_i32(t5_2),
//                                 wit_bindgen::rt::as_i32(t5_3),
//                                 wit_bindgen::rt::as_i32(t5_4),
//                                 wit_bindgen::rt::as_i32(t5_5),
//                                 wit_bindgen::rt::as_i32(t5_6),
//                                 wit_bindgen::rt::as_i32(t5_7),
//                                 wit_bindgen::rt::as_i32(scope_id4),
//                             )
//                         }
//                     };
//                     let ptr7 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "send")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_send"
//                         )]
//                         fn wit_import(
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                         );
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         ptr1,
//                         len1,
//                         result6_0,
//                         result6_1,
//                         result6_2,
//                         result6_3,
//                         result6_4,
//                         result6_5,
//                         result6_6,
//                         result6_7,
//                         result6_8,
//                         result6_9,
//                         result6_10,
//                         result6_11,
//                         ptr7,
//                     );
//                     match i32::from(*((ptr7 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr7 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr7 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get the current bound address.
//             ///
//             /// # Typical errors
//             /// - `not-bound`: The socket is not bound to any local address.
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
//             /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
//             /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
//             pub fn local_address(this: UdpSocket) -> Result<IpSocketAddress, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 36]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "local-address")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_local-address"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(super::super::super::wasi::sockets::network::Ipv4SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, address:(i32::from(*((ptr0 + 10) as *const u8)) as u8, i32::from(*((ptr0 + 11) as *const u8)) as u8, i32::from(*((ptr0 + 12) as *const u8)) as u8, i32::from(*((ptr0 + 13) as *const u8)) as u8), }),
//                   #[cfg(debug_assertions)]1 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(not(debug_assertions))]_ => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Get the address set with `connect`.
//             ///
//             /// # Typical errors
//             /// - `not-connected`: The socket is not connected to a remote address. (ENOTCONN)
//             ///
//             /// # References
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
//             /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
//             pub fn remote_address(this: UdpSocket) -> Result<IpSocketAddress, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 36]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "remote-address")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_remote-address"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv4(super::super::super::wasi::sockets::network::Ipv4SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, address:(i32::from(*((ptr0 + 10) as *const u8)) as u8, i32::from(*((ptr0 + 11) as *const u8)) as u8, i32::from(*((ptr0 + 12) as *const u8)) as u8, i32::from(*((ptr0 + 13) as *const u8)) as u8), }),
//                   #[cfg(debug_assertions)]1 => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(not(debug_assertions))]_ => super::super::super::wasi::sockets::network::IpSocketAddress::Ipv6(super::super::super::wasi::sockets::network::Ipv6SocketAddress{port:i32::from(*((ptr0 + 8) as *const u16)) as u16, flow_info:*((ptr0 + 12) as *const i32) as u32, address:(i32::from(*((ptr0 + 16) as *const u16)) as u16, i32::from(*((ptr0 + 18) as *const u16)) as u16, i32::from(*((ptr0 + 20) as *const u16)) as u16, i32::from(*((ptr0 + 22) as *const u16)) as u16, i32::from(*((ptr0 + 24) as *const u16)) as u16, i32::from(*((ptr0 + 26) as *const u16)) as u16, i32::from(*((ptr0 + 28) as *const u16)) as u16, i32::from(*((ptr0 + 30) as *const u16)) as u16), scope_id:*((ptr0 + 32) as *const i32) as u32, }),
//                   #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Whether this is a IPv4 or IPv6 socket.
//             ///
//             /// Equivalent to the SO_DOMAIN socket option.
//             pub fn address_family(this: UdpSocket) -> IpAddressFamily {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "address-family")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_address-family"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     {
//                         #[cfg(debug_assertions)]
//                         {
//                             match ret {
//                 0 => super::super::super::wasi::sockets::network::IpAddressFamily::Ipv4,
//                 1 => super::super::super::wasi::sockets::network::IpAddressFamily::Ipv6,
//                 _ => panic!("invalid enum discriminant"),
//               }
//                         }
//                         #[cfg(not(debug_assertions))]
//                         {
//                             ::core::mem::transmute::<
//                                 _,
//                                 super::super::super::wasi::sockets::network::IpAddressFamily,
//                             >(ret as u8)
//                         }
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Whether IPv4 compatibility (dual-stack) mode is disabled or not.
//             ///
//             /// Equivalent to the IPV6_V6ONLY socket option.
//             ///
//             /// # Typical errors
//             /// - `ipv6-only-operation`:  (get/set) `this` socket is an IPv4 socket.
//             /// - `already-bound`:        (set) The socket is already bound.
//             /// - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)
//             /// - `concurrency-conflict`: (set) Another `bind` or `connect` operation is already in progress. (EALREADY)
//             pub fn ipv6_only(this: UdpSocket) -> Result<bool, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "ipv6-only")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_ipv6-only"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok({
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<u8, bool>(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                                     0 => false,
//                                     1 => true,
//                                     _ => panic!("invalid bool discriminant"),
//                                 }
//                             }
//                         }),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_ipv6_only(this: UdpSocket, value: bool) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-ipv6-only")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_set-ipv6-only"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         match value {
//                             true => 1,
//                             false => 0,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
//             ///
//             /// # Typical errors
//             /// - `concurrency-conflict`: (set) Another `bind` or `connect` operation is already in progress. (EALREADY)
//             pub fn unicast_hop_limit(this: UdpSocket) -> Result<u8, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "unicast-hop-limit")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_unicast-hop-limit"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(i32::from(*((ptr0 + 1) as *const u8)) as u8),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_unicast_hop_limit(this: UdpSocket, value: u8) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-unicast-hop-limit")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_set-unicast-hop-limit"
//                         )]
//                         fn wit_import(_: i32, _: i32, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i32(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// The kernel buffer space reserved for sends/receives on this socket.
//             ///
//             /// Note #1: an implementation may choose to cap or round the buffer size when setting the value.
//             /// In other words, after setting a value, reading the same setting back may return a different value.
//             ///
//             /// Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of
//             /// actual data to be sent/received by the application, because the kernel might also use the buffer space
//             /// for internal metadata structures.
//             ///
//             /// Fails when this socket is in the Listening state.
//             ///
//             /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
//             ///
//             /// # Typical errors
//             /// - `concurrency-conflict`: (set) Another `bind` or `connect` operation is already in progress. (EALREADY)
//             pub fn receive_buffer_size(this: UdpSocket) -> Result<u64, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "receive-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_receive-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 8) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_receive_buffer_size(this: UdpSocket, value: u64) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-receive-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_set-receive-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn send_buffer_size(this: UdpSocket) -> Result<u64, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(8))]
//                     struct RetArea([u8; 16]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "send-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_send-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this), ptr0);
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 8) as *const i64) as u64),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 8) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 8) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             pub fn set_send_buffer_size(this: UdpSocket, value: u64) -> Result<(), ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([u8; 2]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "set-send-buffer-size")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_set-send-buffer-size"
//                         )]
//                         fn wit_import(_: i32, _: i64, _: i32);
//                     }
//                     wit_import(
//                         wit_bindgen::rt::as_i32(this),
//                         wit_bindgen::rt::as_i64(value),
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(()),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 1) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 1) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Create a `pollable` which will resolve once the socket is ready for I/O.
//             ///
//             /// Note: this function is here for WASI Preview2 only.
//             /// It's planned to be removed when `future` is natively supported in Preview3.
//             pub fn subscribe(this: UdpSocket) -> Pollable {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_subscribe"
//                         )]
//                         fn wit_import(_: i32) -> i32;
//                     }
//                     let ret = wit_import(wit_bindgen::rt::as_i32(this));
//                     ret as u32
//                 }
//             }
//             #[allow(clippy::all)]
//             /// Dispose of the specified `udp-socket`, after which it may no longer be used.
//             ///
//             /// Note: this function is scheduled to be removed when Resources are natively supported in Wit.
//             pub fn drop_udp_socket(this: UdpSocket) {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[link(wasm_import_module = "wasi:sockets/udp")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "drop-udp-socket")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp_drop-udp-socket"
//                         )]
//                         fn wit_import(_: i32);
//                     }
//                     wit_import(wit_bindgen::rt::as_i32(this));
//                 }
//             }
//         }

//         #[allow(clippy::all)]
//         pub mod udp_create_socket {
//             #[used]
//             #[doc(hidden)]
//             #[cfg(target_arch = "wasm32")]
//             static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;

//             pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
//             pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
//             pub type UdpSocket = super::super::super::wasi::sockets::udp::UdpSocket;
//             #[allow(clippy::all)]
//             /// Create a new UDP socket.
//             ///
//             /// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
//             ///
//             /// This function does not require a network capability handle. This is considered to be safe because
//             /// at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind`/`connect` is called,
//             /// the socket is effectively an in-memory configuration object, unable to communicate with the outside world.
//             ///
//             /// All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
//             ///
//             /// # Typical errors
//             /// - `not-supported`:                The host does not support UDP sockets. (EOPNOTSUPP)
//             /// - `address-family-not-supported`: The specified `address-family` is not supported. (EAFNOSUPPORT)
//             /// - `new-socket-limit`:             The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
//             ///
//             /// # References:
//             /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
//             /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
//             /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
//             /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
//             pub fn create_udp_socket(
//                 address_family: IpAddressFamily,
//             ) -> Result<UdpSocket, ErrorCode> {
//                 #[allow(unused_imports)]
//                 use wit_bindgen::rt::{alloc, string::String, vec::Vec};
//                 unsafe {
//                     #[repr(align(4))]
//                     struct RetArea([u8; 8]);
//                     let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
//                     let ptr0 = ret_area.as_mut_ptr() as i32;
//                     #[link(wasm_import_module = "wasi:sockets/udp-create-socket")]
//                     extern "C" {
//                         #[cfg_attr(target_arch = "wasm32", link_name = "create-udp-socket")]
//                         #[cfg_attr(
//                             not(target_arch = "wasm32"),
//                             link_name = "wasi:sockets/udp-create-socket_create-udp-socket"
//                         )]
//                         fn wit_import(_: i32, _: i32);
//                     }
//                     wit_import(
//                         match address_family {
//                             super::super::super::wasi::sockets::network::IpAddressFamily::Ipv4 => 0,
//                             super::super::super::wasi::sockets::network::IpAddressFamily::Ipv6 => 1,
//                         },
//                         ptr0,
//                     );
//                     match i32::from(*((ptr0 + 0) as *const u8)) {
//                         0 => Ok(*((ptr0 + 4) as *const i32) as u32),
//                         1 => Err({
//                             #[cfg(debug_assertions)]
//                             {
//                                 match i32::from(*((ptr0 + 4) as *const u8)) {
//                   0 => super::super::super::wasi::sockets::network::ErrorCode::Unknown,
//                   1 => super::super::super::wasi::sockets::network::ErrorCode::AccessDenied,
//                   2 => super::super::super::wasi::sockets::network::ErrorCode::NotSupported,
//                   3 => super::super::super::wasi::sockets::network::ErrorCode::OutOfMemory,
//                   4 => super::super::super::wasi::sockets::network::ErrorCode::Timeout,
//                   5 => super::super::super::wasi::sockets::network::ErrorCode::ConcurrencyConflict,
//                   6 => super::super::super::wasi::sockets::network::ErrorCode::NotInProgress,
//                   7 => super::super::super::wasi::sockets::network::ErrorCode::WouldBlock,
//                   8 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyNotSupported,
//                   9 => super::super::super::wasi::sockets::network::ErrorCode::AddressFamilyMismatch,
//                   10 => super::super::super::wasi::sockets::network::ErrorCode::InvalidRemoteAddress,
//                   11 => super::super::super::wasi::sockets::network::ErrorCode::Ipv4OnlyOperation,
//                   12 => super::super::super::wasi::sockets::network::ErrorCode::Ipv6OnlyOperation,
//                   13 => super::super::super::wasi::sockets::network::ErrorCode::NewSocketLimit,
//                   14 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyAttached,
//                   15 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyBound,
//                   16 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyConnected,
//                   17 => super::super::super::wasi::sockets::network::ErrorCode::NotBound,
//                   18 => super::super::super::wasi::sockets::network::ErrorCode::NotConnected,
//                   19 => super::super::super::wasi::sockets::network::ErrorCode::AddressNotBindable,
//                   20 => super::super::super::wasi::sockets::network::ErrorCode::AddressInUse,
//                   21 => super::super::super::wasi::sockets::network::ErrorCode::EphemeralPortsExhausted,
//                   22 => super::super::super::wasi::sockets::network::ErrorCode::RemoteUnreachable,
//                   23 => super::super::super::wasi::sockets::network::ErrorCode::AlreadyListening,
//                   24 => super::super::super::wasi::sockets::network::ErrorCode::NotListening,
//                   25 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionRefused,
//                   26 => super::super::super::wasi::sockets::network::ErrorCode::ConnectionReset,
//                   27 => super::super::super::wasi::sockets::network::ErrorCode::DatagramTooLarge,
//                   28 => super::super::super::wasi::sockets::network::ErrorCode::InvalidName,
//                   29 => super::super::super::wasi::sockets::network::ErrorCode::NameUnresolvable,
//                   30 => super::super::super::wasi::sockets::network::ErrorCode::TemporaryResolverFailure,
//                   31 => super::super::super::wasi::sockets::network::ErrorCode::PermanentResolverFailure,
//                   _ => panic!("invalid enum discriminant"),
//                 }
//                             }
//                             #[cfg(not(debug_assertions))]
//                             {
//                                 ::core::mem::transmute::<
//                                     _,
//                                     super::super::super::wasi::sockets::network::ErrorCode,
//                                 >(i32::from(
//                                     *((ptr0 + 4) as *const u8),
//                                 )
//                                     as u8)
//                             }
//                         }),
//                         #[cfg(not(debug_assertions))]
//                         _ => ::core::hint::unreachable_unchecked(),
//                         #[cfg(debug_assertions)]
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//         }
//     }
// }

// #[cfg(target_arch = "wasm32")]
// #[link_section = "component-type:command"]
// #[doc(hidden)]
// pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 12651] = [
//     3, 0, 7, 99, 111, 109, 109, 97, 110, 100, 0, 97, 115, 109, 13, 0, 1, 0, 7, 248, 97, 1, 65, 4,
//     1, 65, 56, 1, 66, 5, 1, 114, 2, 7, 115, 101, 99, 111, 110, 100, 115, 119, 11, 110, 97, 110,
//     111, 115, 101, 99, 111, 110, 100, 115, 121, 4, 0, 8, 100, 97, 116, 101, 116, 105, 109, 101, 3,
//     0, 0, 1, 64, 0, 0, 1, 4, 0, 3, 110, 111, 119, 1, 2, 4, 0, 10, 114, 101, 115, 111, 108, 117,
//     116, 105, 111, 110, 1, 2, 3, 1, 22, 119, 97, 115, 105, 58, 99, 108, 111, 99, 107, 115, 47, 119,
//     97, 108, 108, 45, 99, 108, 111, 99, 107, 5, 0, 1, 66, 8, 1, 121, 4, 0, 8, 112, 111, 108, 108,
//     97, 98, 108, 101, 3, 0, 0, 1, 64, 1, 4, 116, 104, 105, 115, 1, 1, 0, 4, 0, 13, 100, 114, 111,
//     112, 45, 112, 111, 108, 108, 97, 98, 108, 101, 1, 2, 1, 112, 1, 1, 112, 127, 1, 64, 1, 2, 105,
//     110, 3, 0, 4, 4, 0, 11, 112, 111, 108, 108, 45, 111, 110, 101, 111, 102, 102, 1, 5, 3, 1, 14,
//     119, 97, 115, 105, 58, 112, 111, 108, 108, 47, 112, 111, 108, 108, 5, 1, 2, 3, 0, 1, 8, 112,
//     111, 108, 108, 97, 98, 108, 101, 1, 66, 9, 2, 3, 2, 1, 2, 4, 0, 8, 112, 111, 108, 108, 97, 98,
//     108, 101, 3, 0, 0, 1, 119, 4, 0, 7, 105, 110, 115, 116, 97, 110, 116, 3, 0, 2, 1, 64, 0, 0, 3,
//     4, 0, 3, 110, 111, 119, 1, 4, 4, 0, 10, 114, 101, 115, 111, 108, 117, 116, 105, 111, 110, 1, 4,
//     1, 64, 2, 4, 119, 104, 101, 110, 3, 8, 97, 98, 115, 111, 108, 117, 116, 101, 127, 0, 1, 4, 0,
//     9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 5, 3, 1, 27, 119, 97, 115, 105, 58, 99, 108,
//     111, 99, 107, 115, 47, 109, 111, 110, 111, 116, 111, 110, 105, 99, 45, 99, 108, 111, 99, 107,
//     5, 3, 2, 3, 0, 0, 8, 100, 97, 116, 101, 116, 105, 109, 101, 1, 66, 12, 2, 3, 2, 1, 4, 4, 0, 8,
//     100, 97, 116, 101, 116, 105, 109, 101, 3, 0, 0, 1, 114, 3, 10, 117, 116, 99, 45, 111, 102, 102,
//     115, 101, 116, 122, 4, 110, 97, 109, 101, 115, 23, 105, 110, 45, 100, 97, 121, 108, 105, 103,
//     104, 116, 45, 115, 97, 118, 105, 110, 103, 45, 116, 105, 109, 101, 127, 4, 0, 16, 116, 105,
//     109, 101, 122, 111, 110, 101, 45, 100, 105, 115, 112, 108, 97, 121, 3, 0, 2, 1, 121, 4, 0, 8,
//     116, 105, 109, 101, 122, 111, 110, 101, 3, 0, 4, 1, 64, 2, 4, 116, 104, 105, 115, 5, 4, 119,
//     104, 101, 110, 1, 0, 3, 4, 0, 7, 100, 105, 115, 112, 108, 97, 121, 1, 6, 1, 64, 2, 4, 116, 104,
//     105, 115, 5, 4, 119, 104, 101, 110, 1, 0, 122, 4, 0, 10, 117, 116, 99, 45, 111, 102, 102, 115,
//     101, 116, 1, 7, 1, 64, 1, 4, 116, 104, 105, 115, 5, 1, 0, 4, 0, 13, 100, 114, 111, 112, 45,
//     116, 105, 109, 101, 122, 111, 110, 101, 1, 8, 3, 1, 20, 119, 97, 115, 105, 58, 99, 108, 111,
//     99, 107, 115, 47, 116, 105, 109, 101, 122, 111, 110, 101, 5, 5, 1, 66, 39, 2, 3, 2, 1, 2, 4, 0,
//     8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 0, 1, 114, 0, 4, 0, 12, 115, 116, 114, 101, 97,
//     109, 45, 101, 114, 114, 111, 114, 3, 0, 2, 1, 121, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45,
//     115, 116, 114, 101, 97, 109, 3, 0, 4, 1, 121, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116,
//     114, 101, 97, 109, 3, 0, 6, 1, 112, 125, 1, 111, 2, 8, 127, 1, 106, 1, 9, 1, 3, 1, 64, 2, 4,
//     116, 104, 105, 115, 7, 3, 108, 101, 110, 119, 0, 10, 4, 0, 4, 114, 101, 97, 100, 1, 11, 4, 0,
//     13, 98, 108, 111, 99, 107, 105, 110, 103, 45, 114, 101, 97, 100, 1, 11, 1, 111, 2, 119, 127, 1,
//     106, 1, 12, 1, 3, 1, 64, 2, 4, 116, 104, 105, 115, 7, 3, 108, 101, 110, 119, 0, 13, 4, 0, 4,
//     115, 107, 105, 112, 1, 14, 4, 0, 13, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 107, 105,
//     112, 1, 14, 1, 64, 1, 4, 116, 104, 105, 115, 7, 0, 1, 4, 0, 25, 115, 117, 98, 115, 99, 114,
//     105, 98, 101, 45, 116, 111, 45, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 1,
//     15, 1, 64, 1, 4, 116, 104, 105, 115, 7, 1, 0, 4, 0, 17, 100, 114, 111, 112, 45, 105, 110, 112,
//     117, 116, 45, 115, 116, 114, 101, 97, 109, 1, 16, 1, 106, 1, 119, 1, 3, 1, 64, 2, 4, 116, 104,
//     105, 115, 5, 3, 98, 117, 102, 8, 0, 17, 4, 0, 5, 119, 114, 105, 116, 101, 1, 18, 4, 0, 14, 98,
//     108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 1, 18, 1, 64, 2, 4, 116, 104,
//     105, 115, 5, 3, 108, 101, 110, 119, 0, 17, 4, 0, 12, 119, 114, 105, 116, 101, 45, 122, 101,
//     114, 111, 101, 115, 1, 19, 4, 0, 21, 98, 108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105,
//     116, 101, 45, 122, 101, 114, 111, 101, 115, 1, 19, 1, 64, 3, 4, 116, 104, 105, 115, 5, 3, 115,
//     114, 99, 7, 3, 108, 101, 110, 119, 0, 13, 4, 0, 6, 115, 112, 108, 105, 99, 101, 1, 20, 4, 0,
//     15, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 112, 108, 105, 99, 101, 1, 20, 1, 64, 2, 4,
//     116, 104, 105, 115, 5, 3, 115, 114, 99, 7, 0, 17, 4, 0, 7, 102, 111, 114, 119, 97, 114, 100, 1,
//     21, 1, 64, 1, 4, 116, 104, 105, 115, 5, 0, 1, 4, 0, 26, 115, 117, 98, 115, 99, 114, 105, 98,
//     101, 45, 116, 111, 45, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 1, 22, 1,
//     64, 1, 4, 116, 104, 105, 115, 5, 1, 0, 4, 0, 18, 100, 114, 111, 112, 45, 111, 117, 116, 112,
//     117, 116, 45, 115, 116, 114, 101, 97, 109, 1, 23, 3, 1, 15, 119, 97, 115, 105, 58, 105, 111,
//     47, 115, 116, 114, 101, 97, 109, 115, 5, 6, 2, 3, 0, 4, 12, 105, 110, 112, 117, 116, 45, 115,
//     116, 114, 101, 97, 109, 2, 3, 0, 4, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101,
//     97, 109, 1, 66, 117, 2, 3, 2, 1, 7, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101,
//     97, 109, 3, 0, 0, 2, 3, 2, 1, 8, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114,
//     101, 97, 109, 3, 0, 2, 2, 3, 2, 1, 4, 4, 0, 8, 100, 97, 116, 101, 116, 105, 109, 101, 3, 0, 4,
//     1, 110, 1, 14, 115, 121, 109, 108, 105, 110, 107, 45, 102, 111, 108, 108, 111, 119, 4, 0, 10,
//     112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 3, 0, 6, 1, 110, 4, 6, 99, 114, 101, 97, 116,
//     101, 9, 100, 105, 114, 101, 99, 116, 111, 114, 121, 9, 101, 120, 99, 108, 117, 115, 105, 118,
//     101, 8, 116, 114, 117, 110, 99, 97, 116, 101, 4, 0, 10, 111, 112, 101, 110, 45, 102, 108, 97,
//     103, 115, 3, 0, 8, 1, 110, 3, 8, 114, 101, 97, 100, 97, 98, 108, 101, 8, 119, 114, 105, 116,
//     97, 98, 108, 101, 10, 101, 120, 101, 99, 117, 116, 97, 98, 108, 101, 4, 0, 5, 109, 111, 100,
//     101, 115, 3, 0, 10, 1, 119, 4, 0, 10, 108, 105, 110, 107, 45, 99, 111, 117, 110, 116, 3, 0, 12,
//     1, 119, 4, 0, 5, 105, 110, 111, 100, 101, 3, 0, 14, 1, 119, 4, 0, 8, 102, 105, 108, 101, 115,
//     105, 122, 101, 3, 0, 16, 1, 109, 37, 6, 97, 99, 99, 101, 115, 115, 11, 119, 111, 117, 108, 100,
//     45, 98, 108, 111, 99, 107, 7, 97, 108, 114, 101, 97, 100, 121, 14, 98, 97, 100, 45, 100, 101,
//     115, 99, 114, 105, 112, 116, 111, 114, 4, 98, 117, 115, 121, 8, 100, 101, 97, 100, 108, 111,
//     99, 107, 5, 113, 117, 111, 116, 97, 5, 101, 120, 105, 115, 116, 14, 102, 105, 108, 101, 45,
//     116, 111, 111, 45, 108, 97, 114, 103, 101, 21, 105, 108, 108, 101, 103, 97, 108, 45, 98, 121,
//     116, 101, 45, 115, 101, 113, 117, 101, 110, 99, 101, 11, 105, 110, 45, 112, 114, 111, 103, 114,
//     101, 115, 115, 11, 105, 110, 116, 101, 114, 114, 117, 112, 116, 101, 100, 7, 105, 110, 118, 97,
//     108, 105, 100, 2, 105, 111, 12, 105, 115, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 4,
//     108, 111, 111, 112, 14, 116, 111, 111, 45, 109, 97, 110, 121, 45, 108, 105, 110, 107, 115, 12,
//     109, 101, 115, 115, 97, 103, 101, 45, 115, 105, 122, 101, 13, 110, 97, 109, 101, 45, 116, 111,
//     111, 45, 108, 111, 110, 103, 9, 110, 111, 45, 100, 101, 118, 105, 99, 101, 8, 110, 111, 45,
//     101, 110, 116, 114, 121, 7, 110, 111, 45, 108, 111, 99, 107, 19, 105, 110, 115, 117, 102, 102,
//     105, 99, 105, 101, 110, 116, 45, 109, 101, 109, 111, 114, 121, 18, 105, 110, 115, 117, 102,
//     102, 105, 99, 105, 101, 110, 116, 45, 115, 112, 97, 99, 101, 13, 110, 111, 116, 45, 100, 105,
//     114, 101, 99, 116, 111, 114, 121, 9, 110, 111, 116, 45, 101, 109, 112, 116, 121, 15, 110, 111,
//     116, 45, 114, 101, 99, 111, 118, 101, 114, 97, 98, 108, 101, 11, 117, 110, 115, 117, 112, 112,
//     111, 114, 116, 101, 100, 6, 110, 111, 45, 116, 116, 121, 14, 110, 111, 45, 115, 117, 99, 104,
//     45, 100, 101, 118, 105, 99, 101, 8, 111, 118, 101, 114, 102, 108, 111, 119, 13, 110, 111, 116,
//     45, 112, 101, 114, 109, 105, 116, 116, 101, 100, 4, 112, 105, 112, 101, 9, 114, 101, 97, 100,
//     45, 111, 110, 108, 121, 12, 105, 110, 118, 97, 108, 105, 100, 45, 115, 101, 101, 107, 14, 116,
//     101, 120, 116, 45, 102, 105, 108, 101, 45, 98, 117, 115, 121, 12, 99, 114, 111, 115, 115, 45,
//     100, 101, 118, 105, 99, 101, 4, 0, 10, 101, 114, 114, 111, 114, 45, 99, 111, 100, 101, 3, 0,
//     18, 1, 121, 4, 0, 22, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 101, 110, 116, 114, 121,
//     45, 115, 116, 114, 101, 97, 109, 3, 0, 20, 1, 119, 4, 0, 6, 100, 101, 118, 105, 99, 101, 3, 0,
//     22, 1, 109, 8, 7, 117, 110, 107, 110, 111, 119, 110, 12, 98, 108, 111, 99, 107, 45, 100, 101,
//     118, 105, 99, 101, 16, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 100, 101, 118, 105, 99,
//     101, 9, 100, 105, 114, 101, 99, 116, 111, 114, 121, 4, 102, 105, 102, 111, 13, 115, 121, 109,
//     98, 111, 108, 105, 99, 45, 108, 105, 110, 107, 12, 114, 101, 103, 117, 108, 97, 114, 45, 102,
//     105, 108, 101, 6, 115, 111, 99, 107, 101, 116, 4, 0, 15, 100, 101, 115, 99, 114, 105, 112, 116,
//     111, 114, 45, 116, 121, 112, 101, 3, 0, 24, 1, 107, 15, 1, 114, 3, 5, 105, 110, 111, 100, 101,
//     26, 4, 116, 121, 112, 101, 25, 4, 110, 97, 109, 101, 115, 4, 0, 15, 100, 105, 114, 101, 99,
//     116, 111, 114, 121, 45, 101, 110, 116, 114, 121, 3, 0, 27, 1, 110, 6, 4, 114, 101, 97, 100, 5,
//     119, 114, 105, 116, 101, 19, 102, 105, 108, 101, 45, 105, 110, 116, 101, 103, 114, 105, 116,
//     121, 45, 115, 121, 110, 99, 19, 100, 97, 116, 97, 45, 105, 110, 116, 101, 103, 114, 105, 116,
//     121, 45, 115, 121, 110, 99, 20, 114, 101, 113, 117, 101, 115, 116, 101, 100, 45, 119, 114, 105,
//     116, 101, 45, 115, 121, 110, 99, 16, 109, 117, 116, 97, 116, 101, 45, 100, 105, 114, 101, 99,
//     116, 111, 114, 121, 4, 0, 16, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 45, 102, 108,
//     97, 103, 115, 3, 0, 29, 1, 121, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3,
//     0, 31, 1, 113, 3, 9, 110, 111, 45, 99, 104, 97, 110, 103, 101, 0, 0, 3, 110, 111, 119, 0, 0, 9,
//     116, 105, 109, 101, 115, 116, 97, 109, 112, 1, 5, 0, 4, 0, 13, 110, 101, 119, 45, 116, 105,
//     109, 101, 115, 116, 97, 109, 112, 3, 0, 33, 1, 114, 8, 6, 100, 101, 118, 105, 99, 101, 23, 5,
//     105, 110, 111, 100, 101, 15, 4, 116, 121, 112, 101, 25, 10, 108, 105, 110, 107, 45, 99, 111,
//     117, 110, 116, 13, 4, 115, 105, 122, 101, 17, 21, 100, 97, 116, 97, 45, 97, 99, 99, 101, 115,
//     115, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 5, 27, 100, 97, 116, 97, 45, 109, 111,
//     100, 105, 102, 105, 99, 97, 116, 105, 111, 110, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112,
//     5, 23, 115, 116, 97, 116, 117, 115, 45, 99, 104, 97, 110, 103, 101, 45, 116, 105, 109, 101,
//     115, 116, 97, 109, 112, 5, 4, 0, 15, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 45, 115,
//     116, 97, 116, 3, 0, 35, 1, 109, 6, 6, 110, 111, 114, 109, 97, 108, 10, 115, 101, 113, 117, 101,
//     110, 116, 105, 97, 108, 6, 114, 97, 110, 100, 111, 109, 9, 119, 105, 108, 108, 45, 110, 101,
//     101, 100, 9, 100, 111, 110, 116, 45, 110, 101, 101, 100, 8, 110, 111, 45, 114, 101, 117, 115,
//     101, 4, 0, 6, 97, 100, 118, 105, 99, 101, 3, 0, 37, 1, 113, 2, 6, 97, 99, 99, 101, 115, 115, 1,
//     11, 0, 6, 101, 120, 105, 115, 116, 115, 0, 0, 4, 0, 11, 97, 99, 99, 101, 115, 115, 45, 116,
//     121, 112, 101, 3, 0, 39, 1, 106, 1, 1, 1, 19, 1, 64, 2, 4, 116, 104, 105, 115, 32, 6, 111, 102,
//     102, 115, 101, 116, 17, 0, 41, 4, 0, 15, 114, 101, 97, 100, 45, 118, 105, 97, 45, 115, 116,
//     114, 101, 97, 109, 1, 42, 1, 106, 1, 3, 1, 19, 1, 64, 2, 4, 116, 104, 105, 115, 32, 6, 111,
//     102, 102, 115, 101, 116, 17, 0, 43, 4, 0, 16, 119, 114, 105, 116, 101, 45, 118, 105, 97, 45,
//     115, 116, 114, 101, 97, 109, 1, 44, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 43, 4, 0, 17, 97,
//     112, 112, 101, 110, 100, 45, 118, 105, 97, 45, 115, 116, 114, 101, 97, 109, 1, 45, 1, 106, 0,
//     1, 19, 1, 64, 4, 4, 116, 104, 105, 115, 32, 6, 111, 102, 102, 115, 101, 116, 17, 6, 108, 101,
//     110, 103, 116, 104, 17, 6, 97, 100, 118, 105, 99, 101, 38, 0, 46, 4, 0, 6, 97, 100, 118, 105,
//     115, 101, 1, 47, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 46, 4, 0, 9, 115, 121, 110, 99, 45,
//     100, 97, 116, 97, 1, 48, 1, 106, 1, 30, 1, 19, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 49, 4,
//     0, 9, 103, 101, 116, 45, 102, 108, 97, 103, 115, 1, 50, 1, 106, 1, 25, 1, 19, 1, 64, 1, 4, 116,
//     104, 105, 115, 32, 0, 51, 4, 0, 8, 103, 101, 116, 45, 116, 121, 112, 101, 1, 52, 1, 64, 2, 4,
//     116, 104, 105, 115, 32, 4, 115, 105, 122, 101, 17, 0, 46, 4, 0, 8, 115, 101, 116, 45, 115, 105,
//     122, 101, 1, 53, 1, 64, 3, 4, 116, 104, 105, 115, 32, 21, 100, 97, 116, 97, 45, 97, 99, 99,
//     101, 115, 115, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 34, 27, 100, 97, 116, 97, 45,
//     109, 111, 100, 105, 102, 105, 99, 97, 116, 105, 111, 110, 45, 116, 105, 109, 101, 115, 116, 97,
//     109, 112, 34, 0, 46, 4, 0, 9, 115, 101, 116, 45, 116, 105, 109, 101, 115, 1, 54, 1, 112, 125,
//     1, 111, 2, 55, 127, 1, 106, 1, 56, 1, 19, 1, 64, 3, 4, 116, 104, 105, 115, 32, 6, 108, 101,
//     110, 103, 116, 104, 17, 6, 111, 102, 102, 115, 101, 116, 17, 0, 57, 4, 0, 4, 114, 101, 97, 100,
//     1, 58, 1, 106, 1, 17, 1, 19, 1, 64, 3, 4, 116, 104, 105, 115, 32, 6, 98, 117, 102, 102, 101,
//     114, 55, 6, 111, 102, 102, 115, 101, 116, 17, 0, 59, 4, 0, 5, 119, 114, 105, 116, 101, 1, 60,
//     1, 106, 1, 21, 1, 19, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 61, 4, 0, 14, 114, 101, 97, 100,
//     45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 1, 62, 4, 0, 4, 115, 121, 110, 99, 1, 48, 1,
//     64, 2, 4, 116, 104, 105, 115, 32, 4, 112, 97, 116, 104, 115, 0, 46, 4, 0, 19, 99, 114, 101, 97,
//     116, 101, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 97, 116, 1, 63, 1, 106, 1, 36, 1,
//     19, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 192, 0, 4, 0, 4, 115, 116, 97, 116, 1, 65, 1, 64,
//     3, 4, 116, 104, 105, 115, 32, 10, 112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 7, 4, 112, 97,
//     116, 104, 115, 0, 192, 0, 4, 0, 7, 115, 116, 97, 116, 45, 97, 116, 1, 66, 1, 64, 5, 4, 116,
//     104, 105, 115, 32, 10, 112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 7, 4, 112, 97, 116, 104,
//     115, 21, 100, 97, 116, 97, 45, 97, 99, 99, 101, 115, 115, 45, 116, 105, 109, 101, 115, 116, 97,
//     109, 112, 34, 27, 100, 97, 116, 97, 45, 109, 111, 100, 105, 102, 105, 99, 97, 116, 105, 111,
//     110, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 34, 0, 46, 4, 0, 12, 115, 101, 116, 45,
//     116, 105, 109, 101, 115, 45, 97, 116, 1, 67, 1, 64, 5, 4, 116, 104, 105, 115, 32, 14, 111, 108,
//     100, 45, 112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 7, 8, 111, 108, 100, 45, 112, 97, 116,
//     104, 115, 14, 110, 101, 119, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 8, 110,
//     101, 119, 45, 112, 97, 116, 104, 115, 0, 46, 4, 0, 7, 108, 105, 110, 107, 45, 97, 116, 1, 68,
//     1, 106, 1, 32, 1, 19, 1, 64, 6, 4, 116, 104, 105, 115, 32, 10, 112, 97, 116, 104, 45, 102, 108,
//     97, 103, 115, 7, 4, 112, 97, 116, 104, 115, 10, 111, 112, 101, 110, 45, 102, 108, 97, 103, 115,
//     9, 5, 102, 108, 97, 103, 115, 30, 5, 109, 111, 100, 101, 115, 11, 0, 197, 0, 4, 0, 7, 111, 112,
//     101, 110, 45, 97, 116, 1, 70, 1, 106, 1, 115, 1, 19, 1, 64, 2, 4, 116, 104, 105, 115, 32, 4,
//     112, 97, 116, 104, 115, 0, 199, 0, 4, 0, 11, 114, 101, 97, 100, 108, 105, 110, 107, 45, 97,
//     116, 1, 72, 4, 0, 19, 114, 101, 109, 111, 118, 101, 45, 100, 105, 114, 101, 99, 116, 111, 114,
//     121, 45, 97, 116, 1, 63, 1, 64, 4, 4, 116, 104, 105, 115, 32, 8, 111, 108, 100, 45, 112, 97,
//     116, 104, 115, 14, 110, 101, 119, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 8,
//     110, 101, 119, 45, 112, 97, 116, 104, 115, 0, 46, 4, 0, 9, 114, 101, 110, 97, 109, 101, 45, 97,
//     116, 1, 73, 1, 64, 3, 4, 116, 104, 105, 115, 32, 8, 111, 108, 100, 45, 112, 97, 116, 104, 115,
//     8, 110, 101, 119, 45, 112, 97, 116, 104, 115, 0, 46, 4, 0, 10, 115, 121, 109, 108, 105, 110,
//     107, 45, 97, 116, 1, 74, 1, 64, 4, 4, 116, 104, 105, 115, 32, 10, 112, 97, 116, 104, 45, 102,
//     108, 97, 103, 115, 7, 4, 112, 97, 116, 104, 115, 4, 116, 121, 112, 101, 40, 0, 46, 4, 0, 9, 97,
//     99, 99, 101, 115, 115, 45, 97, 116, 1, 75, 4, 0, 14, 117, 110, 108, 105, 110, 107, 45, 102,
//     105, 108, 101, 45, 97, 116, 1, 63, 1, 64, 4, 4, 116, 104, 105, 115, 32, 10, 112, 97, 116, 104,
//     45, 102, 108, 97, 103, 115, 7, 4, 112, 97, 116, 104, 115, 5, 109, 111, 100, 101, 115, 11, 0,
//     46, 4, 0, 26, 99, 104, 97, 110, 103, 101, 45, 102, 105, 108, 101, 45, 112, 101, 114, 109, 105,
//     115, 115, 105, 111, 110, 115, 45, 97, 116, 1, 76, 4, 0, 31, 99, 104, 97, 110, 103, 101, 45,
//     100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 112, 101, 114, 109, 105, 115, 115, 105, 111,
//     110, 115, 45, 97, 116, 1, 76, 4, 0, 11, 108, 111, 99, 107, 45, 115, 104, 97, 114, 101, 100, 1,
//     48, 4, 0, 14, 108, 111, 99, 107, 45, 101, 120, 99, 108, 117, 115, 105, 118, 101, 1, 48, 4, 0,
//     15, 116, 114, 121, 45, 108, 111, 99, 107, 45, 115, 104, 97, 114, 101, 100, 1, 48, 4, 0, 18,
//     116, 114, 121, 45, 108, 111, 99, 107, 45, 101, 120, 99, 108, 117, 115, 105, 118, 101, 1, 48, 4,
//     0, 6, 117, 110, 108, 111, 99, 107, 1, 48, 1, 64, 1, 4, 116, 104, 105, 115, 32, 1, 0, 4, 0, 15,
//     100, 114, 111, 112, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 1, 77, 1, 107, 28, 1,
//     106, 1, 206, 0, 1, 19, 1, 64, 1, 4, 116, 104, 105, 115, 21, 0, 207, 0, 4, 0, 20, 114, 101, 97,
//     100, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 101, 110, 116, 114, 121, 1, 80, 1, 64,
//     1, 4, 116, 104, 105, 115, 21, 1, 0, 4, 0, 27, 100, 114, 111, 112, 45, 100, 105, 114, 101, 99,
//     116, 111, 114, 121, 45, 101, 110, 116, 114, 121, 45, 115, 116, 114, 101, 97, 109, 1, 81, 3, 1,
//     26, 119, 97, 115, 105, 58, 102, 105, 108, 101, 115, 121, 115, 116, 101, 109, 47, 102, 105, 108,
//     101, 115, 121, 115, 116, 101, 109, 5, 9, 1, 66, 20, 1, 121, 4, 0, 7, 110, 101, 116, 119, 111,
//     114, 107, 3, 0, 0, 1, 111, 8, 123, 123, 123, 123, 123, 123, 123, 123, 4, 0, 12, 105, 112, 118,
//     54, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 2, 1, 114, 4, 4, 112, 111, 114, 116, 123, 9,
//     102, 108, 111, 119, 45, 105, 110, 102, 111, 121, 7, 97, 100, 100, 114, 101, 115, 115, 3, 8,
//     115, 99, 111, 112, 101, 45, 105, 100, 121, 4, 0, 19, 105, 112, 118, 54, 45, 115, 111, 99, 107,
//     101, 116, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 4, 1, 111, 4, 125, 125, 125, 125, 4, 0,
//     12, 105, 112, 118, 52, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 6, 1, 114, 2, 4, 112, 111,
//     114, 116, 123, 7, 97, 100, 100, 114, 101, 115, 115, 7, 4, 0, 19, 105, 112, 118, 52, 45, 115,
//     111, 99, 107, 101, 116, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 8, 1, 113, 2, 4, 105, 112,
//     118, 52, 1, 9, 0, 4, 105, 112, 118, 54, 1, 5, 0, 4, 0, 17, 105, 112, 45, 115, 111, 99, 107,
//     101, 116, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 10, 1, 109, 2, 4, 105, 112, 118, 52, 4,
//     105, 112, 118, 54, 4, 0, 17, 105, 112, 45, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109,
//     105, 108, 121, 3, 0, 12, 1, 113, 2, 4, 105, 112, 118, 52, 1, 7, 0, 4, 105, 112, 118, 54, 1, 3,
//     0, 4, 0, 10, 105, 112, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 14, 1, 109, 32, 7, 117, 110,
//     107, 110, 111, 119, 110, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 13,
//     110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 13, 111, 117, 116, 45, 111,
//     102, 45, 109, 101, 109, 111, 114, 121, 7, 116, 105, 109, 101, 111, 117, 116, 20, 99, 111, 110,
//     99, 117, 114, 114, 101, 110, 99, 121, 45, 99, 111, 110, 102, 108, 105, 99, 116, 15, 110, 111,
//     116, 45, 105, 110, 45, 112, 114, 111, 103, 114, 101, 115, 115, 11, 119, 111, 117, 108, 100, 45,
//     98, 108, 111, 99, 107, 28, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105, 108, 121,
//     45, 110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 23, 97, 100, 100, 114, 101,
//     115, 115, 45, 102, 97, 109, 105, 108, 121, 45, 109, 105, 115, 109, 97, 116, 99, 104, 22, 105,
//     110, 118, 97, 108, 105, 100, 45, 114, 101, 109, 111, 116, 101, 45, 97, 100, 100, 114, 101, 115,
//     115, 19, 105, 112, 118, 52, 45, 111, 110, 108, 121, 45, 111, 112, 101, 114, 97, 116, 105, 111,
//     110, 19, 105, 112, 118, 54, 45, 111, 110, 108, 121, 45, 111, 112, 101, 114, 97, 116, 105, 111,
//     110, 16, 110, 101, 119, 45, 115, 111, 99, 107, 101, 116, 45, 108, 105, 109, 105, 116, 16, 97,
//     108, 114, 101, 97, 100, 121, 45, 97, 116, 116, 97, 99, 104, 101, 100, 13, 97, 108, 114, 101,
//     97, 100, 121, 45, 98, 111, 117, 110, 100, 17, 97, 108, 114, 101, 97, 100, 121, 45, 99, 111,
//     110, 110, 101, 99, 116, 101, 100, 9, 110, 111, 116, 45, 98, 111, 117, 110, 100, 13, 110, 111,
//     116, 45, 99, 111, 110, 110, 101, 99, 116, 101, 100, 20, 97, 100, 100, 114, 101, 115, 115, 45,
//     110, 111, 116, 45, 98, 105, 110, 100, 97, 98, 108, 101, 14, 97, 100, 100, 114, 101, 115, 115,
//     45, 105, 110, 45, 117, 115, 101, 25, 101, 112, 104, 101, 109, 101, 114, 97, 108, 45, 112, 111,
//     114, 116, 115, 45, 101, 120, 104, 97, 117, 115, 116, 101, 100, 18, 114, 101, 109, 111, 116,
//     101, 45, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 17, 97, 108, 114, 101, 97, 100,
//     121, 45, 108, 105, 115, 116, 101, 110, 105, 110, 103, 13, 110, 111, 116, 45, 108, 105, 115,
//     116, 101, 110, 105, 110, 103, 18, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 114, 101,
//     102, 117, 115, 101, 100, 16, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 114, 101, 115,
//     101, 116, 18, 100, 97, 116, 97, 103, 114, 97, 109, 45, 116, 111, 111, 45, 108, 97, 114, 103,
//     101, 12, 105, 110, 118, 97, 108, 105, 100, 45, 110, 97, 109, 101, 17, 110, 97, 109, 101, 45,
//     117, 110, 114, 101, 115, 111, 108, 118, 97, 98, 108, 101, 26, 116, 101, 109, 112, 111, 114, 97,
//     114, 121, 45, 114, 101, 115, 111, 108, 118, 101, 114, 45, 102, 97, 105, 108, 117, 114, 101, 26,
//     112, 101, 114, 109, 97, 110, 101, 110, 116, 45, 114, 101, 115, 111, 108, 118, 101, 114, 45,
//     102, 97, 105, 108, 117, 114, 101, 4, 0, 10, 101, 114, 114, 111, 114, 45, 99, 111, 100, 101, 3,
//     0, 16, 1, 64, 1, 4, 116, 104, 105, 115, 1, 1, 0, 4, 0, 12, 100, 114, 111, 112, 45, 110, 101,
//     116, 119, 111, 114, 107, 1, 18, 3, 1, 20, 119, 97, 115, 105, 58, 115, 111, 99, 107, 101, 116,
//     115, 47, 110, 101, 116, 119, 111, 114, 107, 5, 10, 2, 3, 0, 6, 7, 110, 101, 116, 119, 111, 114,
//     107, 1, 66, 4, 2, 3, 2, 1, 11, 4, 0, 7, 110, 101, 116, 119, 111, 114, 107, 3, 0, 0, 1, 64, 0,
//     0, 1, 4, 0, 16, 105, 110, 115, 116, 97, 110, 99, 101, 45, 110, 101, 116, 119, 111, 114, 107, 1,
//     2, 3, 1, 29, 119, 97, 115, 105, 58, 115, 111, 99, 107, 101, 116, 115, 47, 105, 110, 115, 116,
//     97, 110, 99, 101, 45, 110, 101, 116, 119, 111, 114, 107, 5, 12, 2, 3, 0, 6, 10, 101, 114, 114,
//     111, 114, 45, 99, 111, 100, 101, 2, 3, 0, 6, 10, 105, 112, 45, 97, 100, 100, 114, 101, 115,
//     115, 2, 3, 0, 6, 17, 105, 112, 45, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105,
//     108, 121, 1, 66, 24, 2, 3, 2, 1, 2, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 0, 2,
//     3, 2, 1, 11, 4, 0, 7, 110, 101, 116, 119, 111, 114, 107, 3, 0, 2, 2, 3, 2, 1, 13, 4, 0, 10,
//     101, 114, 114, 111, 114, 45, 99, 111, 100, 101, 3, 0, 4, 2, 3, 2, 1, 14, 4, 0, 10, 105, 112,
//     45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 6, 2, 3, 2, 1, 15, 4, 0, 17, 105, 112, 45, 97, 100,
//     100, 114, 101, 115, 115, 45, 102, 97, 109, 105, 108, 121, 3, 0, 8, 1, 121, 4, 0, 22, 114, 101,
//     115, 111, 108, 118, 101, 45, 97, 100, 100, 114, 101, 115, 115, 45, 115, 116, 114, 101, 97, 109,
//     3, 0, 10, 1, 107, 9, 1, 106, 1, 11, 1, 5, 1, 64, 4, 7, 110, 101, 116, 119, 111, 114, 107, 3, 4,
//     110, 97, 109, 101, 115, 14, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105, 108, 121,
//     12, 19, 105, 110, 99, 108, 117, 100, 101, 45, 117, 110, 97, 118, 97, 105, 108, 97, 98, 108,
//     101, 127, 0, 13, 4, 0, 17, 114, 101, 115, 111, 108, 118, 101, 45, 97, 100, 100, 114, 101, 115,
//     115, 101, 115, 1, 14, 1, 107, 7, 1, 106, 1, 15, 1, 5, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0,
//     16, 4, 0, 20, 114, 101, 115, 111, 108, 118, 101, 45, 110, 101, 120, 116, 45, 97, 100, 100, 114,
//     101, 115, 115, 1, 17, 1, 64, 1, 4, 116, 104, 105, 115, 11, 1, 0, 4, 0, 27, 100, 114, 111, 112,
//     45, 114, 101, 115, 111, 108, 118, 101, 45, 97, 100, 100, 114, 101, 115, 115, 45, 115, 116, 114,
//     101, 97, 109, 1, 18, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 1, 4, 0, 9, 115, 117, 98, 115, 99,
//     114, 105, 98, 101, 1, 19, 3, 1, 27, 119, 97, 115, 105, 58, 115, 111, 99, 107, 101, 116, 115,
//     47, 105, 112, 45, 110, 97, 109, 101, 45, 108, 111, 111, 107, 117, 112, 5, 16, 2, 3, 0, 6, 17,
//     105, 112, 45, 115, 111, 99, 107, 101, 116, 45, 97, 100, 100, 114, 101, 115, 115, 1, 66, 70, 2,
//     3, 2, 1, 7, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 0, 2, 3,
//     2, 1, 8, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 2, 2,
//     3, 2, 1, 2, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 4, 2, 3, 2, 1, 11, 4, 0, 7,
//     110, 101, 116, 119, 111, 114, 107, 3, 0, 6, 2, 3, 2, 1, 13, 4, 0, 10, 101, 114, 114, 111, 114,
//     45, 99, 111, 100, 101, 3, 0, 8, 2, 3, 2, 1, 17, 4, 0, 17, 105, 112, 45, 115, 111, 99, 107, 101,
//     116, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 10, 2, 3, 2, 1, 15, 4, 0, 17, 105, 112, 45,
//     97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105, 108, 121, 3, 0, 12, 1, 121, 4, 0, 10,
//     116, 99, 112, 45, 115, 111, 99, 107, 101, 116, 3, 0, 14, 1, 109, 3, 7, 114, 101, 99, 101, 105,
//     118, 101, 4, 115, 101, 110, 100, 4, 98, 111, 116, 104, 4, 0, 13, 115, 104, 117, 116, 100, 111,
//     119, 110, 45, 116, 121, 112, 101, 3, 0, 16, 1, 106, 0, 1, 9, 1, 64, 3, 4, 116, 104, 105, 115,
//     15, 7, 110, 101, 116, 119, 111, 114, 107, 7, 13, 108, 111, 99, 97, 108, 45, 97, 100, 100, 114,
//     101, 115, 115, 11, 0, 18, 4, 0, 10, 115, 116, 97, 114, 116, 45, 98, 105, 110, 100, 1, 19, 1,
//     64, 1, 4, 116, 104, 105, 115, 15, 0, 18, 4, 0, 11, 102, 105, 110, 105, 115, 104, 45, 98, 105,
//     110, 100, 1, 20, 1, 64, 3, 4, 116, 104, 105, 115, 15, 7, 110, 101, 116, 119, 111, 114, 107, 7,
//     14, 114, 101, 109, 111, 116, 101, 45, 97, 100, 100, 114, 101, 115, 115, 11, 0, 18, 4, 0, 13,
//     115, 116, 97, 114, 116, 45, 99, 111, 110, 110, 101, 99, 116, 1, 21, 1, 111, 2, 1, 3, 1, 106, 1,
//     22, 1, 9, 1, 64, 1, 4, 116, 104, 105, 115, 15, 0, 23, 4, 0, 14, 102, 105, 110, 105, 115, 104,
//     45, 99, 111, 110, 110, 101, 99, 116, 1, 24, 1, 64, 2, 4, 116, 104, 105, 115, 15, 7, 110, 101,
//     116, 119, 111, 114, 107, 7, 0, 18, 4, 0, 12, 115, 116, 97, 114, 116, 45, 108, 105, 115, 116,
//     101, 110, 1, 25, 4, 0, 13, 102, 105, 110, 105, 115, 104, 45, 108, 105, 115, 116, 101, 110, 1,
//     20, 1, 111, 3, 15, 1, 3, 1, 106, 1, 26, 1, 9, 1, 64, 1, 4, 116, 104, 105, 115, 15, 0, 27, 4, 0,
//     6, 97, 99, 99, 101, 112, 116, 1, 28, 1, 106, 1, 11, 1, 9, 1, 64, 1, 4, 116, 104, 105, 115, 15,
//     0, 29, 4, 0, 13, 108, 111, 99, 97, 108, 45, 97, 100, 100, 114, 101, 115, 115, 1, 30, 4, 0, 14,
//     114, 101, 109, 111, 116, 101, 45, 97, 100, 100, 114, 101, 115, 115, 1, 30, 1, 64, 1, 4, 116,
//     104, 105, 115, 15, 0, 13, 4, 0, 14, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105,
//     108, 121, 1, 31, 1, 106, 1, 127, 1, 9, 1, 64, 1, 4, 116, 104, 105, 115, 15, 0, 32, 4, 0, 9,
//     105, 112, 118, 54, 45, 111, 110, 108, 121, 1, 33, 1, 64, 2, 4, 116, 104, 105, 115, 15, 5, 118,
//     97, 108, 117, 101, 127, 0, 18, 4, 0, 13, 115, 101, 116, 45, 105, 112, 118, 54, 45, 111, 110,
//     108, 121, 1, 34, 1, 64, 2, 4, 116, 104, 105, 115, 15, 5, 118, 97, 108, 117, 101, 119, 0, 18, 4,
//     0, 23, 115, 101, 116, 45, 108, 105, 115, 116, 101, 110, 45, 98, 97, 99, 107, 108, 111, 103, 45,
//     115, 105, 122, 101, 1, 35, 4, 0, 10, 107, 101, 101, 112, 45, 97, 108, 105, 118, 101, 1, 33, 4,
//     0, 14, 115, 101, 116, 45, 107, 101, 101, 112, 45, 97, 108, 105, 118, 101, 1, 34, 4, 0, 8, 110,
//     111, 45, 100, 101, 108, 97, 121, 1, 33, 4, 0, 12, 115, 101, 116, 45, 110, 111, 45, 100, 101,
//     108, 97, 121, 1, 34, 1, 106, 1, 125, 1, 9, 1, 64, 1, 4, 116, 104, 105, 115, 15, 0, 36, 4, 0,
//     17, 117, 110, 105, 99, 97, 115, 116, 45, 104, 111, 112, 45, 108, 105, 109, 105, 116, 1, 37, 1,
//     64, 2, 4, 116, 104, 105, 115, 15, 5, 118, 97, 108, 117, 101, 125, 0, 18, 4, 0, 21, 115, 101,
//     116, 45, 117, 110, 105, 99, 97, 115, 116, 45, 104, 111, 112, 45, 108, 105, 109, 105, 116, 1,
//     38, 1, 106, 1, 119, 1, 9, 1, 64, 1, 4, 116, 104, 105, 115, 15, 0, 39, 4, 0, 19, 114, 101, 99,
//     101, 105, 118, 101, 45, 98, 117, 102, 102, 101, 114, 45, 115, 105, 122, 101, 1, 40, 4, 0, 23,
//     115, 101, 116, 45, 114, 101, 99, 101, 105, 118, 101, 45, 98, 117, 102, 102, 101, 114, 45, 115,
//     105, 122, 101, 1, 35, 4, 0, 16, 115, 101, 110, 100, 45, 98, 117, 102, 102, 101, 114, 45, 115,
//     105, 122, 101, 1, 40, 4, 0, 20, 115, 101, 116, 45, 115, 101, 110, 100, 45, 98, 117, 102, 102,
//     101, 114, 45, 115, 105, 122, 101, 1, 35, 1, 64, 1, 4, 116, 104, 105, 115, 15, 0, 5, 4, 0, 9,
//     115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 41, 1, 64, 2, 4, 116, 104, 105, 115, 15, 13, 115,
//     104, 117, 116, 100, 111, 119, 110, 45, 116, 121, 112, 101, 17, 0, 18, 4, 0, 8, 115, 104, 117,
//     116, 100, 111, 119, 110, 1, 42, 1, 64, 1, 4, 116, 104, 105, 115, 15, 1, 0, 4, 0, 15, 100, 114,
//     111, 112, 45, 116, 99, 112, 45, 115, 111, 99, 107, 101, 116, 1, 43, 3, 1, 16, 119, 97, 115,
//     105, 58, 115, 111, 99, 107, 101, 116, 115, 47, 116, 99, 112, 5, 18, 2, 3, 0, 9, 10, 116, 99,
//     112, 45, 115, 111, 99, 107, 101, 116, 1, 66, 11, 2, 3, 2, 1, 11, 4, 0, 7, 110, 101, 116, 119,
//     111, 114, 107, 3, 0, 0, 2, 3, 2, 1, 13, 4, 0, 10, 101, 114, 114, 111, 114, 45, 99, 111, 100,
//     101, 3, 0, 2, 2, 3, 2, 1, 15, 4, 0, 17, 105, 112, 45, 97, 100, 100, 114, 101, 115, 115, 45,
//     102, 97, 109, 105, 108, 121, 3, 0, 4, 2, 3, 2, 1, 19, 4, 0, 10, 116, 99, 112, 45, 115, 111, 99,
//     107, 101, 116, 3, 0, 6, 1, 106, 1, 7, 1, 3, 1, 64, 1, 14, 97, 100, 100, 114, 101, 115, 115, 45,
//     102, 97, 109, 105, 108, 121, 5, 0, 8, 4, 0, 17, 99, 114, 101, 97, 116, 101, 45, 116, 99, 112,
//     45, 115, 111, 99, 107, 101, 116, 1, 9, 3, 1, 30, 119, 97, 115, 105, 58, 115, 111, 99, 107, 101,
//     116, 115, 47, 116, 99, 112, 45, 99, 114, 101, 97, 116, 101, 45, 115, 111, 99, 107, 101, 116, 5,
//     20, 1, 66, 55, 2, 3, 2, 1, 2, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 0, 2, 3, 2,
//     1, 11, 4, 0, 7, 110, 101, 116, 119, 111, 114, 107, 3, 0, 2, 2, 3, 2, 1, 13, 4, 0, 10, 101, 114,
//     114, 111, 114, 45, 99, 111, 100, 101, 3, 0, 4, 2, 3, 2, 1, 17, 4, 0, 17, 105, 112, 45, 115,
//     111, 99, 107, 101, 116, 45, 97, 100, 100, 114, 101, 115, 115, 3, 0, 6, 2, 3, 2, 1, 15, 4, 0,
//     17, 105, 112, 45, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105, 108, 121, 3, 0, 8,
//     1, 121, 4, 0, 10, 117, 100, 112, 45, 115, 111, 99, 107, 101, 116, 3, 0, 10, 1, 112, 125, 1,
//     114, 2, 4, 100, 97, 116, 97, 12, 14, 114, 101, 109, 111, 116, 101, 45, 97, 100, 100, 114, 101,
//     115, 115, 7, 4, 0, 8, 100, 97, 116, 97, 103, 114, 97, 109, 3, 0, 13, 1, 106, 0, 1, 5, 1, 64, 3,
//     4, 116, 104, 105, 115, 11, 7, 110, 101, 116, 119, 111, 114, 107, 3, 13, 108, 111, 99, 97, 108,
//     45, 97, 100, 100, 114, 101, 115, 115, 7, 0, 15, 4, 0, 10, 115, 116, 97, 114, 116, 45, 98, 105,
//     110, 100, 1, 16, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 15, 4, 0, 11, 102, 105, 110, 105, 115,
//     104, 45, 98, 105, 110, 100, 1, 17, 1, 64, 3, 4, 116, 104, 105, 115, 11, 7, 110, 101, 116, 119,
//     111, 114, 107, 3, 14, 114, 101, 109, 111, 116, 101, 45, 97, 100, 100, 114, 101, 115, 115, 7, 0,
//     15, 4, 0, 13, 115, 116, 97, 114, 116, 45, 99, 111, 110, 110, 101, 99, 116, 1, 18, 4, 0, 14,
//     102, 105, 110, 105, 115, 104, 45, 99, 111, 110, 110, 101, 99, 116, 1, 17, 1, 106, 1, 14, 1, 5,
//     1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 19, 4, 0, 7, 114, 101, 99, 101, 105, 118, 101, 1, 20,
//     1, 64, 2, 4, 116, 104, 105, 115, 11, 8, 100, 97, 116, 97, 103, 114, 97, 109, 14, 0, 15, 4, 0,
//     4, 115, 101, 110, 100, 1, 21, 1, 106, 1, 7, 1, 5, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 22,
//     4, 0, 13, 108, 111, 99, 97, 108, 45, 97, 100, 100, 114, 101, 115, 115, 1, 23, 4, 0, 14, 114,
//     101, 109, 111, 116, 101, 45, 97, 100, 100, 114, 101, 115, 115, 1, 23, 1, 64, 1, 4, 116, 104,
//     105, 115, 11, 0, 9, 4, 0, 14, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97, 109, 105, 108,
//     121, 1, 24, 1, 106, 1, 127, 1, 5, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 25, 4, 0, 9, 105,
//     112, 118, 54, 45, 111, 110, 108, 121, 1, 26, 1, 64, 2, 4, 116, 104, 105, 115, 11, 5, 118, 97,
//     108, 117, 101, 127, 0, 15, 4, 0, 13, 115, 101, 116, 45, 105, 112, 118, 54, 45, 111, 110, 108,
//     121, 1, 27, 1, 106, 1, 125, 1, 5, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 28, 4, 0, 17, 117,
//     110, 105, 99, 97, 115, 116, 45, 104, 111, 112, 45, 108, 105, 109, 105, 116, 1, 29, 1, 64, 2, 4,
//     116, 104, 105, 115, 11, 5, 118, 97, 108, 117, 101, 125, 0, 15, 4, 0, 21, 115, 101, 116, 45,
//     117, 110, 105, 99, 97, 115, 116, 45, 104, 111, 112, 45, 108, 105, 109, 105, 116, 1, 30, 1, 106,
//     1, 119, 1, 5, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 31, 4, 0, 19, 114, 101, 99, 101, 105,
//     118, 101, 45, 98, 117, 102, 102, 101, 114, 45, 115, 105, 122, 101, 1, 32, 1, 64, 2, 4, 116,
//     104, 105, 115, 11, 5, 118, 97, 108, 117, 101, 119, 0, 15, 4, 0, 23, 115, 101, 116, 45, 114,
//     101, 99, 101, 105, 118, 101, 45, 98, 117, 102, 102, 101, 114, 45, 115, 105, 122, 101, 1, 33, 4,
//     0, 16, 115, 101, 110, 100, 45, 98, 117, 102, 102, 101, 114, 45, 115, 105, 122, 101, 1, 32, 4,
//     0, 20, 115, 101, 116, 45, 115, 101, 110, 100, 45, 98, 117, 102, 102, 101, 114, 45, 115, 105,
//     122, 101, 1, 33, 1, 64, 1, 4, 116, 104, 105, 115, 11, 0, 1, 4, 0, 9, 115, 117, 98, 115, 99,
//     114, 105, 98, 101, 1, 34, 1, 64, 1, 4, 116, 104, 105, 115, 11, 1, 0, 4, 0, 15, 100, 114, 111,
//     112, 45, 117, 100, 112, 45, 115, 111, 99, 107, 101, 116, 1, 35, 3, 1, 16, 119, 97, 115, 105,
//     58, 115, 111, 99, 107, 101, 116, 115, 47, 117, 100, 112, 5, 21, 2, 3, 0, 11, 10, 117, 100, 112,
//     45, 115, 111, 99, 107, 101, 116, 1, 66, 11, 2, 3, 2, 1, 11, 4, 0, 7, 110, 101, 116, 119, 111,
//     114, 107, 3, 0, 0, 2, 3, 2, 1, 13, 4, 0, 10, 101, 114, 114, 111, 114, 45, 99, 111, 100, 101, 3,
//     0, 2, 2, 3, 2, 1, 15, 4, 0, 17, 105, 112, 45, 97, 100, 100, 114, 101, 115, 115, 45, 102, 97,
//     109, 105, 108, 121, 3, 0, 4, 2, 3, 2, 1, 22, 4, 0, 10, 117, 100, 112, 45, 115, 111, 99, 107,
//     101, 116, 3, 0, 6, 1, 106, 1, 7, 1, 3, 1, 64, 1, 14, 97, 100, 100, 114, 101, 115, 115, 45, 102,
//     97, 109, 105, 108, 121, 5, 0, 8, 4, 0, 17, 99, 114, 101, 97, 116, 101, 45, 117, 100, 112, 45,
//     115, 111, 99, 107, 101, 116, 1, 9, 3, 1, 30, 119, 97, 115, 105, 58, 115, 111, 99, 107, 101,
//     116, 115, 47, 117, 100, 112, 45, 99, 114, 101, 97, 116, 101, 45, 115, 111, 99, 107, 101, 116,
//     5, 23, 1, 66, 5, 1, 112, 125, 1, 64, 1, 3, 108, 101, 110, 119, 0, 0, 4, 0, 16, 103, 101, 116,
//     45, 114, 97, 110, 100, 111, 109, 45, 98, 121, 116, 101, 115, 1, 1, 1, 64, 0, 0, 119, 4, 0, 14,
//     103, 101, 116, 45, 114, 97, 110, 100, 111, 109, 45, 117, 54, 52, 1, 2, 3, 1, 18, 119, 97, 115,
//     105, 58, 114, 97, 110, 100, 111, 109, 47, 114, 97, 110, 100, 111, 109, 5, 24, 1, 66, 5, 1, 112,
//     125, 1, 64, 1, 3, 108, 101, 110, 119, 0, 0, 4, 0, 25, 103, 101, 116, 45, 105, 110, 115, 101,
//     99, 117, 114, 101, 45, 114, 97, 110, 100, 111, 109, 45, 98, 121, 116, 101, 115, 1, 1, 1, 64, 0,
//     0, 119, 4, 0, 23, 103, 101, 116, 45, 105, 110, 115, 101, 99, 117, 114, 101, 45, 114, 97, 110,
//     100, 111, 109, 45, 117, 54, 52, 1, 2, 3, 1, 20, 119, 97, 115, 105, 58, 114, 97, 110, 100, 111,
//     109, 47, 105, 110, 115, 101, 99, 117, 114, 101, 5, 25, 1, 66, 3, 1, 111, 2, 119, 119, 1, 64, 0,
//     0, 0, 4, 0, 13, 105, 110, 115, 101, 99, 117, 114, 101, 45, 115, 101, 101, 100, 1, 1, 3, 1, 25,
//     119, 97, 115, 105, 58, 114, 97, 110, 100, 111, 109, 47, 105, 110, 115, 101, 99, 117, 114, 101,
//     45, 115, 101, 101, 100, 5, 26, 1, 66, 7, 1, 111, 2, 115, 115, 1, 112, 0, 1, 64, 0, 0, 1, 4, 0,
//     15, 103, 101, 116, 45, 101, 110, 118, 105, 114, 111, 110, 109, 101, 110, 116, 1, 2, 1, 112,
//     115, 1, 64, 0, 0, 3, 4, 0, 13, 103, 101, 116, 45, 97, 114, 103, 117, 109, 101, 110, 116, 115,
//     1, 4, 3, 1, 25, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97, 115, 101, 47, 101, 110, 118,
//     105, 114, 111, 110, 109, 101, 110, 116, 5, 27, 2, 3, 0, 5, 10, 100, 101, 115, 99, 114, 105,
//     112, 116, 111, 114, 1, 66, 10, 2, 3, 2, 1, 28, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116,
//     111, 114, 3, 0, 0, 2, 3, 2, 1, 7, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101,
//     97, 109, 3, 0, 2, 2, 3, 2, 1, 8, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114,
//     101, 97, 109, 3, 0, 4, 1, 111, 2, 1, 115, 1, 112, 6, 1, 64, 0, 0, 7, 4, 0, 15, 103, 101, 116,
//     45, 100, 105, 114, 101, 99, 116, 111, 114, 105, 101, 115, 1, 8, 3, 1, 22, 119, 97, 115, 105,
//     58, 99, 108, 105, 45, 98, 97, 115, 101, 47, 112, 114, 101, 111, 112, 101, 110, 115, 5, 29, 1,
//     66, 3, 1, 106, 0, 0, 1, 64, 1, 6, 115, 116, 97, 116, 117, 115, 0, 1, 0, 4, 0, 4, 101, 120, 105,
//     116, 1, 1, 3, 1, 18, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97, 115, 101, 47, 101, 120,
//     105, 116, 5, 30, 1, 66, 4, 2, 3, 2, 1, 7, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114,
//     101, 97, 109, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 9, 103, 101, 116, 45, 115, 116, 100, 105, 110, 1,
//     2, 3, 1, 19, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97, 115, 101, 47, 115, 116, 100, 105,
//     110, 5, 31, 1, 66, 4, 2, 3, 2, 1, 8, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114,
//     101, 97, 109, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 10, 103, 101, 116, 45, 115, 116, 100, 111, 117,
//     116, 1, 2, 3, 1, 20, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97, 115, 101, 47, 115, 116,
//     100, 111, 117, 116, 5, 32, 1, 66, 4, 2, 3, 2, 1, 8, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45,
//     115, 116, 114, 101, 97, 109, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 10, 103, 101, 116, 45, 115, 116,
//     100, 101, 114, 114, 1, 2, 3, 1, 20, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97, 115, 101,
//     47, 115, 116, 100, 101, 114, 114, 5, 33, 4, 1, 19, 117, 110, 117, 115, 101, 100, 58, 109, 97,
//     105, 110, 47, 99, 111, 109, 109, 97, 110, 100, 4, 0, 1, 65, 32, 1, 66, 7, 1, 111, 2, 115, 115,
//     1, 112, 0, 1, 64, 0, 0, 1, 4, 0, 15, 103, 101, 116, 45, 101, 110, 118, 105, 114, 111, 110, 109,
//     101, 110, 116, 1, 2, 1, 112, 115, 1, 64, 0, 0, 3, 4, 0, 13, 103, 101, 116, 45, 97, 114, 103,
//     117, 109, 101, 110, 116, 115, 1, 4, 3, 1, 25, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97,
//     115, 101, 47, 101, 110, 118, 105, 114, 111, 110, 109, 101, 110, 116, 5, 0, 1, 66, 8, 1, 121, 4,
//     0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 0, 1, 64, 1, 4, 116, 104, 105, 115, 1, 1, 0,
//     4, 0, 13, 100, 114, 111, 112, 45, 112, 111, 108, 108, 97, 98, 108, 101, 1, 2, 1, 112, 1, 1,
//     112, 127, 1, 64, 1, 2, 105, 110, 3, 0, 4, 4, 0, 11, 112, 111, 108, 108, 45, 111, 110, 101, 111,
//     102, 102, 1, 5, 3, 1, 14, 119, 97, 115, 105, 58, 112, 111, 108, 108, 47, 112, 111, 108, 108, 5,
//     1, 2, 3, 0, 1, 8, 112, 111, 108, 108, 97, 98, 108, 101, 1, 66, 39, 2, 3, 2, 1, 2, 4, 0, 8, 112,
//     111, 108, 108, 97, 98, 108, 101, 3, 0, 0, 1, 114, 0, 4, 0, 12, 115, 116, 114, 101, 97, 109, 45,
//     101, 114, 114, 111, 114, 3, 0, 2, 1, 121, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116,
//     114, 101, 97, 109, 3, 0, 4, 1, 121, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101,
//     97, 109, 3, 0, 6, 1, 112, 125, 1, 111, 2, 8, 127, 1, 106, 1, 9, 1, 3, 1, 64, 2, 4, 116, 104,
//     105, 115, 7, 3, 108, 101, 110, 119, 0, 10, 4, 0, 4, 114, 101, 97, 100, 1, 11, 4, 0, 13, 98,
//     108, 111, 99, 107, 105, 110, 103, 45, 114, 101, 97, 100, 1, 11, 1, 111, 2, 119, 127, 1, 106, 1,
//     12, 1, 3, 1, 64, 2, 4, 116, 104, 105, 115, 7, 3, 108, 101, 110, 119, 0, 13, 4, 0, 4, 115, 107,
//     105, 112, 1, 14, 4, 0, 13, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 107, 105, 112, 1, 14,
//     1, 64, 1, 4, 116, 104, 105, 115, 7, 0, 1, 4, 0, 25, 115, 117, 98, 115, 99, 114, 105, 98, 101,
//     45, 116, 111, 45, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 1, 15, 1, 64, 1, 4,
//     116, 104, 105, 115, 7, 1, 0, 4, 0, 17, 100, 114, 111, 112, 45, 105, 110, 112, 117, 116, 45,
//     115, 116, 114, 101, 97, 109, 1, 16, 1, 106, 1, 119, 1, 3, 1, 64, 2, 4, 116, 104, 105, 115, 5,
//     3, 98, 117, 102, 8, 0, 17, 4, 0, 5, 119, 114, 105, 116, 101, 1, 18, 4, 0, 14, 98, 108, 111, 99,
//     107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 1, 18, 1, 64, 2, 4, 116, 104, 105, 115, 5, 3,
//     108, 101, 110, 119, 0, 17, 4, 0, 12, 119, 114, 105, 116, 101, 45, 122, 101, 114, 111, 101, 115,
//     1, 19, 4, 0, 21, 98, 108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 45, 122,
//     101, 114, 111, 101, 115, 1, 19, 1, 64, 3, 4, 116, 104, 105, 115, 5, 3, 115, 114, 99, 7, 3, 108,
//     101, 110, 119, 0, 13, 4, 0, 6, 115, 112, 108, 105, 99, 101, 1, 20, 4, 0, 15, 98, 108, 111, 99,
//     107, 105, 110, 103, 45, 115, 112, 108, 105, 99, 101, 1, 20, 1, 64, 2, 4, 116, 104, 105, 115, 5,
//     3, 115, 114, 99, 7, 0, 17, 4, 0, 7, 102, 111, 114, 119, 97, 114, 100, 1, 21, 1, 64, 1, 4, 116,
//     104, 105, 115, 5, 0, 1, 4, 0, 26, 115, 117, 98, 115, 99, 114, 105, 98, 101, 45, 116, 111, 45,
//     111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 1, 22, 1, 64, 1, 4, 116, 104,
//     105, 115, 5, 1, 0, 4, 0, 18, 100, 114, 111, 112, 45, 111, 117, 116, 112, 117, 116, 45, 115,
//     116, 114, 101, 97, 109, 1, 23, 3, 1, 15, 119, 97, 115, 105, 58, 105, 111, 47, 115, 116, 114,
//     101, 97, 109, 115, 5, 3, 1, 66, 5, 1, 114, 2, 7, 115, 101, 99, 111, 110, 100, 115, 119, 11,
//     110, 97, 110, 111, 115, 101, 99, 111, 110, 100, 115, 121, 4, 0, 8, 100, 97, 116, 101, 116, 105,
//     109, 101, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 3, 110, 111, 119, 1, 2, 4, 0, 10, 114, 101, 115, 111,
//     108, 117, 116, 105, 111, 110, 1, 2, 3, 1, 22, 119, 97, 115, 105, 58, 99, 108, 111, 99, 107,
//     115, 47, 119, 97, 108, 108, 45, 99, 108, 111, 99, 107, 5, 4, 2, 3, 0, 2, 12, 105, 110, 112,
//     117, 116, 45, 115, 116, 114, 101, 97, 109, 2, 3, 0, 2, 13, 111, 117, 116, 112, 117, 116, 45,
//     115, 116, 114, 101, 97, 109, 2, 3, 0, 3, 8, 100, 97, 116, 101, 116, 105, 109, 101, 1, 66, 117,
//     2, 3, 2, 1, 5, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 0, 2,
//     3, 2, 1, 6, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 2,
//     2, 3, 2, 1, 7, 4, 0, 8, 100, 97, 116, 101, 116, 105, 109, 101, 3, 0, 4, 1, 110, 1, 14, 115,
//     121, 109, 108, 105, 110, 107, 45, 102, 111, 108, 108, 111, 119, 4, 0, 10, 112, 97, 116, 104,
//     45, 102, 108, 97, 103, 115, 3, 0, 6, 1, 110, 4, 6, 99, 114, 101, 97, 116, 101, 9, 100, 105,
//     114, 101, 99, 116, 111, 114, 121, 9, 101, 120, 99, 108, 117, 115, 105, 118, 101, 8, 116, 114,
//     117, 110, 99, 97, 116, 101, 4, 0, 10, 111, 112, 101, 110, 45, 102, 108, 97, 103, 115, 3, 0, 8,
//     1, 110, 3, 8, 114, 101, 97, 100, 97, 98, 108, 101, 8, 119, 114, 105, 116, 97, 98, 108, 101, 10,
//     101, 120, 101, 99, 117, 116, 97, 98, 108, 101, 4, 0, 5, 109, 111, 100, 101, 115, 3, 0, 10, 1,
//     119, 4, 0, 10, 108, 105, 110, 107, 45, 99, 111, 117, 110, 116, 3, 0, 12, 1, 119, 4, 0, 5, 105,
//     110, 111, 100, 101, 3, 0, 14, 1, 119, 4, 0, 8, 102, 105, 108, 101, 115, 105, 122, 101, 3, 0,
//     16, 1, 109, 37, 6, 97, 99, 99, 101, 115, 115, 11, 119, 111, 117, 108, 100, 45, 98, 108, 111,
//     99, 107, 7, 97, 108, 114, 101, 97, 100, 121, 14, 98, 97, 100, 45, 100, 101, 115, 99, 114, 105,
//     112, 116, 111, 114, 4, 98, 117, 115, 121, 8, 100, 101, 97, 100, 108, 111, 99, 107, 5, 113, 117,
//     111, 116, 97, 5, 101, 120, 105, 115, 116, 14, 102, 105, 108, 101, 45, 116, 111, 111, 45, 108,
//     97, 114, 103, 101, 21, 105, 108, 108, 101, 103, 97, 108, 45, 98, 121, 116, 101, 45, 115, 101,
//     113, 117, 101, 110, 99, 101, 11, 105, 110, 45, 112, 114, 111, 103, 114, 101, 115, 115, 11, 105,
//     110, 116, 101, 114, 114, 117, 112, 116, 101, 100, 7, 105, 110, 118, 97, 108, 105, 100, 2, 105,
//     111, 12, 105, 115, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 4, 108, 111, 111, 112, 14,
//     116, 111, 111, 45, 109, 97, 110, 121, 45, 108, 105, 110, 107, 115, 12, 109, 101, 115, 115, 97,
//     103, 101, 45, 115, 105, 122, 101, 13, 110, 97, 109, 101, 45, 116, 111, 111, 45, 108, 111, 110,
//     103, 9, 110, 111, 45, 100, 101, 118, 105, 99, 101, 8, 110, 111, 45, 101, 110, 116, 114, 121, 7,
//     110, 111, 45, 108, 111, 99, 107, 19, 105, 110, 115, 117, 102, 102, 105, 99, 105, 101, 110, 116,
//     45, 109, 101, 109, 111, 114, 121, 18, 105, 110, 115, 117, 102, 102, 105, 99, 105, 101, 110,
//     116, 45, 115, 112, 97, 99, 101, 13, 110, 111, 116, 45, 100, 105, 114, 101, 99, 116, 111, 114,
//     121, 9, 110, 111, 116, 45, 101, 109, 112, 116, 121, 15, 110, 111, 116, 45, 114, 101, 99, 111,
//     118, 101, 114, 97, 98, 108, 101, 11, 117, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 6,
//     110, 111, 45, 116, 116, 121, 14, 110, 111, 45, 115, 117, 99, 104, 45, 100, 101, 118, 105, 99,
//     101, 8, 111, 118, 101, 114, 102, 108, 111, 119, 13, 110, 111, 116, 45, 112, 101, 114, 109, 105,
//     116, 116, 101, 100, 4, 112, 105, 112, 101, 9, 114, 101, 97, 100, 45, 111, 110, 108, 121, 12,
//     105, 110, 118, 97, 108, 105, 100, 45, 115, 101, 101, 107, 14, 116, 101, 120, 116, 45, 102, 105,
//     108, 101, 45, 98, 117, 115, 121, 12, 99, 114, 111, 115, 115, 45, 100, 101, 118, 105, 99, 101,
//     4, 0, 10, 101, 114, 114, 111, 114, 45, 99, 111, 100, 101, 3, 0, 18, 1, 121, 4, 0, 22, 100, 105,
//     114, 101, 99, 116, 111, 114, 121, 45, 101, 110, 116, 114, 121, 45, 115, 116, 114, 101, 97, 109,
//     3, 0, 20, 1, 119, 4, 0, 6, 100, 101, 118, 105, 99, 101, 3, 0, 22, 1, 109, 8, 7, 117, 110, 107,
//     110, 111, 119, 110, 12, 98, 108, 111, 99, 107, 45, 100, 101, 118, 105, 99, 101, 16, 99, 104,
//     97, 114, 97, 99, 116, 101, 114, 45, 100, 101, 118, 105, 99, 101, 9, 100, 105, 114, 101, 99,
//     116, 111, 114, 121, 4, 102, 105, 102, 111, 13, 115, 121, 109, 98, 111, 108, 105, 99, 45, 108,
//     105, 110, 107, 12, 114, 101, 103, 117, 108, 97, 114, 45, 102, 105, 108, 101, 6, 115, 111, 99,
//     107, 101, 116, 4, 0, 15, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 45, 116, 121, 112,
//     101, 3, 0, 24, 1, 107, 15, 1, 114, 3, 5, 105, 110, 111, 100, 101, 26, 4, 116, 121, 112, 101,
//     25, 4, 110, 97, 109, 101, 115, 4, 0, 15, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 101,
//     110, 116, 114, 121, 3, 0, 27, 1, 110, 6, 4, 114, 101, 97, 100, 5, 119, 114, 105, 116, 101, 19,
//     102, 105, 108, 101, 45, 105, 110, 116, 101, 103, 114, 105, 116, 121, 45, 115, 121, 110, 99, 19,
//     100, 97, 116, 97, 45, 105, 110, 116, 101, 103, 114, 105, 116, 121, 45, 115, 121, 110, 99, 20,
//     114, 101, 113, 117, 101, 115, 116, 101, 100, 45, 119, 114, 105, 116, 101, 45, 115, 121, 110,
//     99, 16, 109, 117, 116, 97, 116, 101, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 4, 0, 16,
//     100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 45, 102, 108, 97, 103, 115, 3, 0, 29, 1, 121,
//     4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 31, 1, 113, 3, 9, 110, 111,
//     45, 99, 104, 97, 110, 103, 101, 0, 0, 3, 110, 111, 119, 0, 0, 9, 116, 105, 109, 101, 115, 116,
//     97, 109, 112, 1, 5, 0, 4, 0, 13, 110, 101, 119, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112,
//     3, 0, 33, 1, 114, 8, 6, 100, 101, 118, 105, 99, 101, 23, 5, 105, 110, 111, 100, 101, 15, 4,
//     116, 121, 112, 101, 25, 10, 108, 105, 110, 107, 45, 99, 111, 117, 110, 116, 13, 4, 115, 105,
//     122, 101, 17, 21, 100, 97, 116, 97, 45, 97, 99, 99, 101, 115, 115, 45, 116, 105, 109, 101, 115,
//     116, 97, 109, 112, 5, 27, 100, 97, 116, 97, 45, 109, 111, 100, 105, 102, 105, 99, 97, 116, 105,
//     111, 110, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 5, 23, 115, 116, 97, 116, 117, 115,
//     45, 99, 104, 97, 110, 103, 101, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 5, 4, 0, 15,
//     100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 45, 115, 116, 97, 116, 3, 0, 35, 1, 109, 6, 6,
//     110, 111, 114, 109, 97, 108, 10, 115, 101, 113, 117, 101, 110, 116, 105, 97, 108, 6, 114, 97,
//     110, 100, 111, 109, 9, 119, 105, 108, 108, 45, 110, 101, 101, 100, 9, 100, 111, 110, 116, 45,
//     110, 101, 101, 100, 8, 110, 111, 45, 114, 101, 117, 115, 101, 4, 0, 6, 97, 100, 118, 105, 99,
//     101, 3, 0, 37, 1, 113, 2, 6, 97, 99, 99, 101, 115, 115, 1, 11, 0, 6, 101, 120, 105, 115, 116,
//     115, 0, 0, 4, 0, 11, 97, 99, 99, 101, 115, 115, 45, 116, 121, 112, 101, 3, 0, 39, 1, 106, 1, 1,
//     1, 19, 1, 64, 2, 4, 116, 104, 105, 115, 32, 6, 111, 102, 102, 115, 101, 116, 17, 0, 41, 4, 0,
//     15, 114, 101, 97, 100, 45, 118, 105, 97, 45, 115, 116, 114, 101, 97, 109, 1, 42, 1, 106, 1, 3,
//     1, 19, 1, 64, 2, 4, 116, 104, 105, 115, 32, 6, 111, 102, 102, 115, 101, 116, 17, 0, 43, 4, 0,
//     16, 119, 114, 105, 116, 101, 45, 118, 105, 97, 45, 115, 116, 114, 101, 97, 109, 1, 44, 1, 64,
//     1, 4, 116, 104, 105, 115, 32, 0, 43, 4, 0, 17, 97, 112, 112, 101, 110, 100, 45, 118, 105, 97,
//     45, 115, 116, 114, 101, 97, 109, 1, 45, 1, 106, 0, 1, 19, 1, 64, 4, 4, 116, 104, 105, 115, 32,
//     6, 111, 102, 102, 115, 101, 116, 17, 6, 108, 101, 110, 103, 116, 104, 17, 6, 97, 100, 118, 105,
//     99, 101, 38, 0, 46, 4, 0, 6, 97, 100, 118, 105, 115, 101, 1, 47, 1, 64, 1, 4, 116, 104, 105,
//     115, 32, 0, 46, 4, 0, 9, 115, 121, 110, 99, 45, 100, 97, 116, 97, 1, 48, 1, 106, 1, 30, 1, 19,
//     1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 49, 4, 0, 9, 103, 101, 116, 45, 102, 108, 97, 103, 115,
//     1, 50, 1, 106, 1, 25, 1, 19, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0, 51, 4, 0, 8, 103, 101,
//     116, 45, 116, 121, 112, 101, 1, 52, 1, 64, 2, 4, 116, 104, 105, 115, 32, 4, 115, 105, 122, 101,
//     17, 0, 46, 4, 0, 8, 115, 101, 116, 45, 115, 105, 122, 101, 1, 53, 1, 64, 3, 4, 116, 104, 105,
//     115, 32, 21, 100, 97, 116, 97, 45, 97, 99, 99, 101, 115, 115, 45, 116, 105, 109, 101, 115, 116,
//     97, 109, 112, 34, 27, 100, 97, 116, 97, 45, 109, 111, 100, 105, 102, 105, 99, 97, 116, 105,
//     111, 110, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 34, 0, 46, 4, 0, 9, 115, 101, 116,
//     45, 116, 105, 109, 101, 115, 1, 54, 1, 112, 125, 1, 111, 2, 55, 127, 1, 106, 1, 56, 1, 19, 1,
//     64, 3, 4, 116, 104, 105, 115, 32, 6, 108, 101, 110, 103, 116, 104, 17, 6, 111, 102, 102, 115,
//     101, 116, 17, 0, 57, 4, 0, 4, 114, 101, 97, 100, 1, 58, 1, 106, 1, 17, 1, 19, 1, 64, 3, 4, 116,
//     104, 105, 115, 32, 6, 98, 117, 102, 102, 101, 114, 55, 6, 111, 102, 102, 115, 101, 116, 17, 0,
//     59, 4, 0, 5, 119, 114, 105, 116, 101, 1, 60, 1, 106, 1, 21, 1, 19, 1, 64, 1, 4, 116, 104, 105,
//     115, 32, 0, 61, 4, 0, 14, 114, 101, 97, 100, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 1,
//     62, 4, 0, 4, 115, 121, 110, 99, 1, 48, 1, 64, 2, 4, 116, 104, 105, 115, 32, 4, 112, 97, 116,
//     104, 115, 0, 46, 4, 0, 19, 99, 114, 101, 97, 116, 101, 45, 100, 105, 114, 101, 99, 116, 111,
//     114, 121, 45, 97, 116, 1, 63, 1, 106, 1, 36, 1, 19, 1, 64, 1, 4, 116, 104, 105, 115, 32, 0,
//     192, 0, 4, 0, 4, 115, 116, 97, 116, 1, 65, 1, 64, 3, 4, 116, 104, 105, 115, 32, 10, 112, 97,
//     116, 104, 45, 102, 108, 97, 103, 115, 7, 4, 112, 97, 116, 104, 115, 0, 192, 0, 4, 0, 7, 115,
//     116, 97, 116, 45, 97, 116, 1, 66, 1, 64, 5, 4, 116, 104, 105, 115, 32, 10, 112, 97, 116, 104,
//     45, 102, 108, 97, 103, 115, 7, 4, 112, 97, 116, 104, 115, 21, 100, 97, 116, 97, 45, 97, 99, 99,
//     101, 115, 115, 45, 116, 105, 109, 101, 115, 116, 97, 109, 112, 34, 27, 100, 97, 116, 97, 45,
//     109, 111, 100, 105, 102, 105, 99, 97, 116, 105, 111, 110, 45, 116, 105, 109, 101, 115, 116, 97,
//     109, 112, 34, 0, 46, 4, 0, 12, 115, 101, 116, 45, 116, 105, 109, 101, 115, 45, 97, 116, 1, 67,
//     1, 64, 5, 4, 116, 104, 105, 115, 32, 14, 111, 108, 100, 45, 112, 97, 116, 104, 45, 102, 108,
//     97, 103, 115, 7, 8, 111, 108, 100, 45, 112, 97, 116, 104, 115, 14, 110, 101, 119, 45, 100, 101,
//     115, 99, 114, 105, 112, 116, 111, 114, 32, 8, 110, 101, 119, 45, 112, 97, 116, 104, 115, 0, 46,
//     4, 0, 7, 108, 105, 110, 107, 45, 97, 116, 1, 68, 1, 106, 1, 32, 1, 19, 1, 64, 6, 4, 116, 104,
//     105, 115, 32, 10, 112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 7, 4, 112, 97, 116, 104, 115,
//     10, 111, 112, 101, 110, 45, 102, 108, 97, 103, 115, 9, 5, 102, 108, 97, 103, 115, 30, 5, 109,
//     111, 100, 101, 115, 11, 0, 197, 0, 4, 0, 7, 111, 112, 101, 110, 45, 97, 116, 1, 70, 1, 106, 1,
//     115, 1, 19, 1, 64, 2, 4, 116, 104, 105, 115, 32, 4, 112, 97, 116, 104, 115, 0, 199, 0, 4, 0,
//     11, 114, 101, 97, 100, 108, 105, 110, 107, 45, 97, 116, 1, 72, 4, 0, 19, 114, 101, 109, 111,
//     118, 101, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 97, 116, 1, 63, 1, 64, 4, 4, 116,
//     104, 105, 115, 32, 8, 111, 108, 100, 45, 112, 97, 116, 104, 115, 14, 110, 101, 119, 45, 100,
//     101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 8, 110, 101, 119, 45, 112, 97, 116, 104, 115,
//     0, 46, 4, 0, 9, 114, 101, 110, 97, 109, 101, 45, 97, 116, 1, 73, 1, 64, 3, 4, 116, 104, 105,
//     115, 32, 8, 111, 108, 100, 45, 112, 97, 116, 104, 115, 8, 110, 101, 119, 45, 112, 97, 116, 104,
//     115, 0, 46, 4, 0, 10, 115, 121, 109, 108, 105, 110, 107, 45, 97, 116, 1, 74, 1, 64, 4, 4, 116,
//     104, 105, 115, 32, 10, 112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 7, 4, 112, 97, 116, 104,
//     115, 4, 116, 121, 112, 101, 40, 0, 46, 4, 0, 9, 97, 99, 99, 101, 115, 115, 45, 97, 116, 1, 75,
//     4, 0, 14, 117, 110, 108, 105, 110, 107, 45, 102, 105, 108, 101, 45, 97, 116, 1, 63, 1, 64, 4,
//     4, 116, 104, 105, 115, 32, 10, 112, 97, 116, 104, 45, 102, 108, 97, 103, 115, 7, 4, 112, 97,
//     116, 104, 115, 5, 109, 111, 100, 101, 115, 11, 0, 46, 4, 0, 26, 99, 104, 97, 110, 103, 101, 45,
//     102, 105, 108, 101, 45, 112, 101, 114, 109, 105, 115, 115, 105, 111, 110, 115, 45, 97, 116, 1,
//     76, 4, 0, 31, 99, 104, 97, 110, 103, 101, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45,
//     112, 101, 114, 109, 105, 115, 115, 105, 111, 110, 115, 45, 97, 116, 1, 76, 4, 0, 11, 108, 111,
//     99, 107, 45, 115, 104, 97, 114, 101, 100, 1, 48, 4, 0, 14, 108, 111, 99, 107, 45, 101, 120, 99,
//     108, 117, 115, 105, 118, 101, 1, 48, 4, 0, 15, 116, 114, 121, 45, 108, 111, 99, 107, 45, 115,
//     104, 97, 114, 101, 100, 1, 48, 4, 0, 18, 116, 114, 121, 45, 108, 111, 99, 107, 45, 101, 120,
//     99, 108, 117, 115, 105, 118, 101, 1, 48, 4, 0, 6, 117, 110, 108, 111, 99, 107, 1, 48, 1, 64, 1,
//     4, 116, 104, 105, 115, 32, 1, 0, 4, 0, 15, 100, 114, 111, 112, 45, 100, 101, 115, 99, 114, 105,
//     112, 116, 111, 114, 1, 77, 1, 107, 28, 1, 106, 1, 206, 0, 1, 19, 1, 64, 1, 4, 116, 104, 105,
//     115, 21, 0, 207, 0, 4, 0, 20, 114, 101, 97, 100, 45, 100, 105, 114, 101, 99, 116, 111, 114,
//     121, 45, 101, 110, 116, 114, 121, 1, 80, 1, 64, 1, 4, 116, 104, 105, 115, 21, 1, 0, 4, 0, 27,
//     100, 114, 111, 112, 45, 100, 105, 114, 101, 99, 116, 111, 114, 121, 45, 101, 110, 116, 114,
//     121, 45, 115, 116, 114, 101, 97, 109, 1, 81, 3, 1, 26, 119, 97, 115, 105, 58, 102, 105, 108,
//     101, 115, 121, 115, 116, 101, 109, 47, 102, 105, 108, 101, 115, 121, 115, 116, 101, 109, 5, 8,
//     2, 3, 0, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 1, 66, 10, 2, 3, 2, 1, 9, 4,
//     0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 0, 2, 3, 2, 1, 5, 4, 0, 12, 105,
//     110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 2, 2, 3, 2, 1, 6, 4, 0, 13, 111,
//     117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 4, 1, 111, 2, 1, 115, 1, 112,
//     6, 1, 64, 0, 0, 7, 4, 0, 15, 103, 101, 116, 45, 100, 105, 114, 101, 99, 116, 111, 114, 105,
//     101, 115, 1, 8, 3, 1, 22, 119, 97, 115, 105, 58, 99, 108, 105, 45, 98, 97, 115, 101, 47, 112,
//     114, 101, 111, 112, 101, 110, 115, 5, 10, 1, 66, 3, 1, 106, 0, 0, 1, 64, 1, 6, 115, 116, 97,
//     116, 117, 115, 0, 1, 0, 4, 0, 4, 101, 120, 105, 116, 1, 1, 3, 1, 18, 119, 97, 115, 105, 58, 99,
//     108, 105, 45, 98, 97, 115, 101, 47, 101, 120, 105, 116, 5, 11, 3, 0, 13, 111, 117, 116, 112,
//     117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 6, 2, 3, 0, 4, 15, 100, 101, 115, 99, 114,
//     105, 112, 116, 111, 114, 45, 115, 116, 97, 116, 3, 0, 15, 100, 101, 115, 99, 114, 105, 112,
//     116, 111, 114, 45, 115, 116, 97, 116, 3, 0, 13, 1, 112, 115, 1, 64, 1, 1, 115, 15, 0, 121, 4,
//     0, 11, 97, 100, 100, 45, 115, 116, 114, 105, 110, 103, 115, 1, 16, 1, 64, 0, 0, 15, 4, 0, 11,
//     103, 101, 116, 45, 115, 116, 114, 105, 110, 103, 115, 1, 17, 1, 106, 0, 0, 1, 64, 1, 1, 111,
//     12, 0, 18, 4, 0, 16, 119, 114, 105, 116, 101, 45, 115, 116, 114, 105, 110, 103, 115, 45, 116,
//     111, 1, 19, 1, 64, 1, 1, 100, 14, 0, 115, 4, 0, 23, 112, 97, 115, 115, 45, 97, 110, 45, 105,
//     109, 112, 111, 114, 116, 101, 100, 45, 114, 101, 99, 111, 114, 100, 1, 20, 4, 1, 24, 117, 110,
//     117, 115, 101, 100, 58, 109, 97, 105, 110, 47, 116, 101, 115, 116, 45, 114, 101, 97, 99, 116,
//     111, 114, 4, 1, 0, 69, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99,
//     101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110,
//     101, 110, 116, 6, 48, 46, 49, 49, 46, 48, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101,
//     110, 45, 114, 117, 115, 116, 5, 48, 46, 56, 46, 48, 11, 21, 1, 1, 15, 117, 110, 117, 115, 101,
//     100, 58, 109, 97, 105, 110, 47, 119, 105, 116, 3, 0, 0,
// ];

// #[inline(never)]
// #[doc(hidden)]
// #[cfg(target_arch = "wasm32")]
// pub fn __link_section() {}
